<template name="api">
{{#better_markdown}}

<h1 id="api">The Meteor API</h1>

你的javascript代码能运行在两个环境:  *客户端* (浏览器) 和 *服务器端*(一个[Node.js]
(http://nodejs.org/)程序)。这个API涉及到的每一个函数，我们都会指明这个函数适用客户端还是服务器
端, 或者是*通用*。

<h2 id="core"><span>Meteor Core</span></h2>

{{> api_box isClient}}
{{> api_box isServer}}

{{#note}}
`Meteor.isServer` 用来限制代码运行的位置，但是它不能阻止代码发送到客户端。任何你不想
保存到客户端的敏感代码，如包含密码或身份验证的代码，都应保存在`服务端`目录下。
{{/note}}


{{> api_box startup}}
在服务器端，指定函数将在服务器端程序完全启动时候运行。在客户端，则将在DOM加载完后启动。

`startup` 的回掉函数在 `Meteor.startup`被创建后按顺序被调用。

在客户端，所有包加载完，接着加载 `.html` 文件中的 `<body>`模板，
接着是你的应用程序代码，在后才加载 `startup`中的回掉函数。

    //在服务端的startup，当数据库为空时候，将创建一些初始化数据。
    if (Meteor.isServer) {
      Meteor.startup(function () {
        if (Rooms.find().count() === 0) {
          Rooms.insert({name: "Initial room"});
        }
      });
    }

{{> api_box absoluteUrl}}

{{> api_box settings}}

{{> api_box release}}

<h2 id="publishandsubscribe"><span>Publish and subscribe</span></h2>

这些函数控制Meteor服务器如何发布一套档案和如何在客户端订阅这些档案。

{{> api_box publish}}

为了发布档案到客户端, 服务端使用 `Meteor.publish` 并指明两个参数: 要发布的档案的名字, 一个 “publish函数”
在每次客户端订阅该档案时调用.

发布函数会返回一个
[`Collection.Cursor`](#meteor_collection_cursor), 在这种情况下Meteor将发布
该cursor集合的档案到每一个要发布客户端中. 你同样可以返回一个`Collection.Cursor`的数组，
这种情况Meteor就会发布所有的cursor集合.

{{#warning}}
如果你返回一个数组中的多个cursor集合, 那么他们当前必须来自不同的集合.
我们希望在将来的版本解除这个限制.
{{/warning}}

    // server: 发布rooms集合，指定密文.
    Meteor.publish("rooms", function () {
      return Rooms.find({}, {fields: {secretInfo: 0}});
    });

    // ... 发布含有密文的房间且登陆者为admin. 如果客户端订阅了两个数据流，则两个档案
    // 会一起合并到一个rooms集合的档案中
    Meteor.publish("adminSecretInfo", function () {
      return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});
    });

    // 发布指定的档案，模拟进入
    Meteor.publish("roomAndMessages", function (roomId) {
      check(roomId, String);
      return [
        Rooms.find({_id: roomId}, {fields: {secretInfo: 0}}),
        Messages.find({roomId: roomId})
      ];
    });

另外，一个发布函数可以直接控制调用[`added`](#publish_added)(用于添加一个新的发布文档)函数，
[`changed`](#publish_changed)(修改或清除一些fields当一个文档已经发布), 还有
[`removed`](#publish_removed)(移除已经发布的文档)。使用这些方法的发布函数同样可通过[`ready`]
(#publish_ready)调用，一旦初始化档案已经完成。这些方法可以在发布函数里通过`this`调用。

Example:

    // server: 发布当前指定大小的集合
    Meteor.publish("counts-by-room", function (roomId) {
      var self = this;
      check(roomId, String);
      var count = 0;
      var initializing = true;
      var handle = Messages.find({roomId: roomId}).observeChanges({
        added: function (id) {
          count++;
          if (!initializing)
            self.changed("counts", roomId, {count: count});
        },
        removed: function (id) {
          count--;
          self.changed("counts", roomId, {count: count});
        }
        // 不用关心removed或者changed
      });

      //只有在初始化数据已经执行时候才监听。现在返回一个初始值和一个标记的订阅用于ready。
      initializing = false;
      self.added("counts", roomId, {count: count});
      self.ready();

      //当客户端未订阅停止监听
      self.onStop(function () {
        handle.stop();
      });
    });

    // client: 声明新的counts集合
    Counts = new Meteor.Collection("counts");

    // client: 订阅当前房子的数目
    Deps.autorun(function () {
      Meteor.subscribe("counts-by-room", Session.get("roomId"));
    });

    // client: 使用新的集合
    console.log("Current room has " +
                Counts.findOne(Session.get("roomId")).count +
                " messages.");

{{#warning}}
如果你在工程中使用包含`autopublish`包，Meteor在调用`meteor.publish`时会给出
警告。不过你的发布函数仍然可以工作。
{{/warning}}

{{> api_box subscription_userId}}

这是一个常量。然而，当已登用户改变了，这个发布函数将重新运行并产生新的值。

{{> api_box subscription_added}}
{{> api_box subscription_changed}}
{{> api_box subscription_removed}}
{{> api_box subscription_ready}}

{{> api_box subscription_onStop}}

如果你能调用 [`observe`](#observe) 或 [`observeChanges`](#observe_changes)在你的
发布函数，这个用来停止该observes。

{{> api_box subscription_error}}
{{> api_box subscription_stop}}

{{> api_box subscription_connection}}

{{> api_box subscribe}}

当你订阅一个记录集，它告诉服务端发送一条记录到客户端。客户端存储这些到本地的[Minimongo
collections](#meteor_collection), 并以同样的名字当作用于发布函数的`added`,`changed`
, `removed`回调的集合参数. Meteor将按顺序传入属性，直到你在客户端按匹配的集合名声明
[`Meteor.Collection`](#meteor_collection)

    // okay to subscribe (and possibly receive data) before declaring
    // the client collection that will hold it.  assume "allplayers"
    // publishes data from server's "players" collection.
    Meteor.subscribe("allplayers");
    ...
    // client queues incoming players records until ...
    ...
    Players = new Meteor.Collection("players");

客户端会看见一个文档，当文档当前已经在任意订阅的已发布的记录集中.

`onReady`以无参数被调用，在服务端[标记一个订阅作为[`ready`]
(#publish_ready).
当订阅失败或者服务器终止时候,则将触发`onError` ，以[`Meteor.Error`](#meteor_error) 形式，

`Meteor.subscribe`  返回订阅对象的句柄, 一个拥有以下方法的对象。

<dl class="callbacks">
{{#dtdd "stop()"}}
取消订阅. 通常会导致服务器直接从客户端缓存中删除订阅数据。
{{/dtdd}}

{{#dtdd "ready()"}}
如果服务器[标记的订阅已经准备](#publish_ready)则为真.一个响应式数据源码.
{{/dtdd}}
</dl>

如果你调用的`Meteor.subcribe`包含一个 [响应计算](#reactivity),
例如，使用[`Deps.autorun`](#deps_autorun), 当计算失效或者停止时订阅就会自动取消；
它不需要调用`stop`在订阅的时候，内部会自动运行。然而，如果你的函数的下一个迭代订阅了同样的
记录集(同样的名字和同样的函数)，Meteor很聪明的会跳过"未订阅/重新订阅"。例如：

    Deps.autorun(function () {
      Meteor.subscribe("chat", {room: Session.get("current-room")});
      Meteor.subscribe("privateMessages");
    });

这个订阅用于在当前房间获取聊天信息和私有信息。当你调用`Session.set("current-room",
"new-room")`改变房间时候, Meteor将更新房间的聊天信息，并停止订阅原来房间的聊天信息，
并继续保持订阅你私有的信息.

如果超过一个订阅发送一个冲突的值，在一个指定域中(同样的集合名，文档ID，或域名)，那么
在客户端的这个值将成被发布的值的其中一个，且是任意选择的。

<h2 id="methods_header"><span>Methods</span></h2>

Methods是Meteor客户端能调用的远程函数.

{{> api_box methods}}

Example:

    Meteor.methods({
      foo: function (arg1, arg2) {
        check(arg1, String);
        check(arg2, [Number]);
        // .. do stuff ..
        if (you want to throw an error)
          throw new Meteor.Error(404, "Can't find my pants");
        return "some return value";
      },

      bar: function () {
        // .. do other stuff ..
        return "baz";
      }
    });

定义在服务端的`methods`能被客户端远程调用。它们必须返回一个[EJSON](#ejson) -- 可用的值
或抛出一个异常。 在方法的内部，`this`被绑定到调用该方法的对象，该对象提供一下属性：

* `isSimulation`: 一个布尔值，当调用者为"存根"时.
* `unblock`: 当被调用时，允许客户端的下一个方法开始执行。
* `userId`: 当前用户的id.
* `setUserId`: 一个函数用于连接当前客户端和用户。
* `connection`: 在服务器端, 该方法调用的[connection](#meteor_onconnection)被收到.

调用客户端的`methods`方法定义了一个*存根*函数用来关联服务端相同名字的方法。你不需要为你的
方法定义一个存根函数如果你不想要的话。在这种情况, 方法调用只是一种类似在其他系统中的远程程序
调用，且你必须等待服务器端的结果返回。

如果你不想定义一个存根，当一个客户端调用服务端方法时，它还是会平行的调用它的存根。在客户端，
一个存根的返回会被忽略。存根运行所产生的副作用：它是用来模拟服务端方法去做什么，但是没有等待
往返产生的延迟。如果一个存根报错，它将被记录到控制台。

你可以在任意时间使用方法，因为数据库存取器提供了
([`insert`](#insert), [`update`](#update), [`remove`](#remove))等方法。
且发送相同的写入请求到服务端。当服务端响应时，客户端更新本地缓存并写入这同样发生在服务端。

{{> api_box method_invocation_userId}}

用户id是一个任意的字符串-通常用户id记录在数据库中。你可以设置它,通过`setUserId`方法。
如果你使用 [Meteor accounts system](#accounts_api)
那么它会帮你处理。

{{> api_box method_invocation_setUserId}}

在连接的时候调用方法用于改变当前登陆的用户。这简单的设置了`userId`用于以后连接时接收的方法调用.
设置`null`可退出连接。

如果你使用
[Meteor绑定的用户系统](#accounts_api),
那么它就应该符合`_id`在[`Meteor.users`](#meteor_users)集合的文档的域.

`setUserId` 没有回溯能力. 它影响当前方法调用和未来方法调用。任何先前的方法调用仍然
能看`userId`的值，在它已经开始并已经生效时候。

{{> api_box method_invocation_isSimulation}}

{{> api_box method_invocation_unblock}}

在服务端，来自客户端的方法一次运行一个。来自客户端第N+1次调用不会开始，直到第第n次调用返回。
然而，通过`this.unblock`你不能改变这种现象。这只会允许你在第N+1次调用运行在一个新的连接上。

{{> api_box method_invocation_connection}}

{{> api_box error}}

如果你想从方法返回一个错误，直接抛出一个异常。
方法能抛出任意的异常。
但是`Meteor.Error`是唯一一类能从服务端发送到客户端的异常。
如果一个方法函数抛出一个不同的异常，那么它会被映射到一个被处理过的版本。
具体而言，如果一个`处理过的错误`抛出的错误字段被处理为一个
`Meteor.Error`,
那么这个错误将被发送到客户端。除非，没有任何处理过的错误版本，客户端将接受到
`Meteor.Error(500, 'Internal server error')`.

{{> api_box meteor_call}}

这是讲如何调用方法。它会在服务端运行方法。
如果一个存根可用，它也会在客户端运行存根。
(类似的`Meteor.call`的方法有[`Meteor.apply`](#meteor_apply),
该方法除了你可以指定参数为一个数组, 而不是使用单独的参数，
且你能指定一些操作来控制方法的执行.)

如果你包含一个回调函数当作最后的参数(不能只包含一个函数，因为函数是不可序列化的),该方法将被
异步执行：特别情况它什么都没返回且也不会抛出异常。当方法执行完(可能发生在`Meteor.call`返回前)，
回调函数将被以两个参数执行：`error` 和 `result`。如果一个错误被抛出，这个`error`将是
一个错误对象。否则，`error`将是undefined且返回的数据(可能也是undefined)将被保存在
`result`。

    // 异步调用
    Meteor.call('foo', 1, 2, function (error, result) { ... } );

如果你在服务端没有传递一个回调，该方法调用将被阻塞直到方法执行完成。最终它将返回方法的值，
或者它抛出一个异常。(可能映射到服务端的500错误，如果远程异常抛出，且它不是一个`Meteor.Error`
异常)

    // 同步调用
    var result = Meteor.call('foo', 1, 2);

在客户端，如果你没有传递一个回调，且你不在一个存根的里边呢，调用将返回 `undefiend` ,
且你将没办法活的方法的返回值。这是因为客户端没有通道，所以事实上没有任何办法能阻塞一个远程
方法的执行。

最后，如果你在客户端的存根里边，且调用其他方法，其他方法不会被执行(不产生RPC，没任何“真正”
的发生)。如果其他方法有一个存根，存根立足于该方法且该方法被执行. 该方法被调用的返回值是该存根
函数的返回值。客户端同步执行一个存根没有出现问题，这也是为什么一个客户端在方法体内
同样使用`Meteor.call`没有问题，如前所述。

Meteor跟踪数据库写操作，不管是客户端还是服务端，都不会直接执行`异步回调`直到所有的服务端
写入数据替换了本地缓存的存根的写入数据。在某些情况，可以有一个延时发生在返回方法值和写操作间：
例如，如果另一个方法仍然未写入到相同的文档，本地的缓存可能不会是最新的直到其他方法也已经完成。
如果你想要马上执行方法返回在它从服务端返回时候，即使该方法的的写操作还未完成，你可以指定一个
`onResultReceived` 到 [`Meteor.apply`](#meteor_apply).

{{> api_box meteor_apply}}

`Meteor.apply` 类似于 `Meteor.call`, 除了方法参数是通过数组而非直接作为arguments，
且你能指定客户端如何操作该方法。

<h2 id="connections"><span>服务端连接</span></h2>

这些函数管理并检查网络连接，在Meteor的客户端和服务端之间。

{{> api_box status}}

该方法返回一个连接状态在客户端和服务端之间。返回值是一个对象，拥有以下字段：

<dl class="objdesc">
{{#dtdd name="connected" type="Boolean"}}
  连接上服务器则为真。如果为假，变化和方法调用将被排队直到连接重新建立。
{{/dtdd}}

{{#dtdd name="status" type="String"}}
  描述当前的重连状态.可能的值为:
    `connected`(连接已经建立并运行),
    `connecting`(未连接，且正在试图打开一个新的连接),
    `failed`(永久连接失败，如，服务端和客户端支持不同版本的DDP),
    `waiting`(连接失败，且等待建立新的连接),
    `offline`(用户未建立连接)。
{{/dtdd}}

{{#dtdd name="retryCount" type="Number"}}
  在失去连接时候客户端重新连接的次数。连上时为0。
{{/dtdd}}

{{#dtdd name="retryTime" type="Number or undefined"}}
  下次企图重连的估计时间。要获取到下一个连接的时间，可使用
  `retryTime - (new Date()).getTime()`。
  这个值只有在`status`为`waiting`时候有。
{{/dtdd}}

{{#dtdd name="reason" type="String or undefined"}}
  `status` 是 `failed`, 这是一个描述连接为什么会失败。
{{/dtdd}}
</dl>

这是一个[响应式](#reactivity) 数据源, 代替使用回调通知你信息改变,
你可以在
[template](#templates) 或 [computation](#deps_autorun)
来获取一个实时的更新。

{{> api_box reconnect}}

{{> api_box disconnect}}

调用断开方法，并停止一切实时数据更新。在客户端断开时它不会再接受来自集合的更新，方法调用将被进入队列
知道连接重新建立，热代码推进将不可用。

调用 [Meteor.reconnect](#meteor_reconnect) 可重启连接并恢复数据传输。

这个能被用在节省电池，在手机设备上，当不需要更新数据时。

{{> api_box onConnection}}

`onConnection` 返回一个对象，这个对象包含一个单独方法`stop`. 调用`stop`可注销回调，
这样回调将不再被新连接调用。

回调被调用时包含一个参数，服务端的`connection`代表来自客户端的连接。这个对象拥有以下字段：

<dl class="objdesc">
{{#dtdd name="id" type="String"}}
一个全局唯一的连接id
{{/dtdd}}

{{#dtdd name="close" type="Function"}}
关闭这个DDP连接。客户端可以自由的重新连接，但将接收到一个新的连接，并赋一个新的`id`.
{{/dtdd}}

{{#dtdd name="onClose" type="Function"}}
注册一个回调当连接关闭时候。如果连接已经关闭，这个回调将直接被调用。
{{/dtdd}}
</dl>

{{#note}}
目前，当客户端重新连接服务端(如暂时失去互联网连接)，它每次都会获得一个新的连接。
`onConnection`的回调会被重新调用，且新的连接将拥有新的连接`id`。

在将来，当客户端重连被完全实施，来自客户端的重连将连到服务端相同的连接上: 这个`onConnection`的回调
不再被重复调用, 且连接将仍然还有新的连接`id`。

{{/note}}


{{> api_box connect}}

为了调用其他Meteor应用或者订阅它的数据，调用`DDP.connect`使用其他应用的URL。
`DDP.connect` 返回一个对象提供以下字段:

* `subscribe` -
  订阅一条记录,见
  [Meteor.subscribe](#meteor_subscribe).
* `call` -
  调用方法，见 [Meteor.call](#meteor_call).
* `apply` -
  使用数组参数调用一个方法，见
  [Meteor.apply](#meteor_apply).
* `methods` -
  定义只客户端使用的存根，存根的方法定义在远程服务器, 见
  [Meteor.methods](#meteor_methods).
* `status` -
  获取当前的连接状态，见
  [Meteor.status](#meteor_status).
* `reconnect` -
  见 [Meteor.reconnect](#meteor_reconnect).
* `disconnect` -
  见 [Meteor.disconnect](#meteor_disconnect).
* `onReconnect` -
  将此设定成一个函数被调用在第一次重新连接的时候。这个函数将在其他未执行的函数之前调用。
  例如，这个可以用在重建新连接响应的身份验证上。

默认情况，客户端打开它们正在加载的服务器连接，当你调用
`Meteor.subscribe`, `Meteor.status`, `Meteor.call`, 或
`Meteor.apply`, 你将使用连接返回到默认服务器。


<h2 id="collections"><span>集合</span></h2>

Meteor将数据存储到*collections*.开始，你可以使用
`new Meteor.Collection`声明一个集合。

{{> api_box meteor_collection}}

调用类似于生命一个传统的ORM(Object-Relation Mapper)
模型为中心的框架。它被建立为一个*集合*(一个存储记录或文档的地方), 集合可以用于存储特定类型的信息，
例如用户，文章，分数，或者代办事宜，或者任意在你应用程序中的事项。任何的文档都是一个EJSON 对象。
它包含一个`_id`属性，这个属性用来标记唯一的集合，Meteor会在第一次创建文档的时候就设定它。

    // common code on client and server declares livedata-managed mongo
    // collection.
    Chatrooms = new Meteor.Collection("chatrooms");
    Messages = new Meteor.Collection("messages");

这个函数返回一个对象，这个对象可以[`插入`](#insert) 文档，
[`更新`](#update) 它的属性，
[`移除`](#remove) 他们, 或者 在匹配任意标准的集合中[`寻找`](#find)文档。
这些方法和流行的Mongo数据库API相兼容。相同的的数据库API可以工作在客户端也可以在服务端(如下)。

    // 返回我的信息的数组
    var myMessages = Messages.find({userId: Session.get('myUserId')}).fetch();

    // 创建一条新的信息
    Messages.insert({text: "Hello, world!"});

    // 标记我的第一条信息为"impotant"
    Messages.update(myMessages[0]._id, {$set: {important: true}});

如果你在创建集合时传递一个`name`,那么你可声明一个持久化的集合 -- 一个可以存储在服务端且被所有用户
所见。客户端的代码和服务端的带没法都可以使用相同的集合和使用相同的API.

特别的，当你传递`name`，将发生：

* 在服务端， 一个拥有该名字的集合被创建到后段Mongo服务器.当你在服务端调用该集合的方法，
他们直接转换为正常的Mongo操作 (在检测出你的[存取控制为允许时候](#allow))

* 在客户端，一个Minimongo实例被创建，Minimongo 本质上是一个内存，非持久性的用纯javascript实现的Mongo.
它提供一个本地缓存用来存储该数据库的子集, 在客户端[查询](#find)也是直接从缓存中获取，没有通知服务端

* 当你在客户端写入数据
 ([`insert`](#insert),[`update`](#update), [`remove`](#remove)),
 命令直接在客户端执行，同时，它在传到服务端并再运行。`即时数据包`就是用这种方式。

如果你传递 `null` 当作 `name` ，那么你将传递本地的集合。
他非同步到任何地方；它只是本地暂存器, 并支持Mongo方式 --  [`find`](#find), [`insert`](#insert),
[`update`](#update), and [`remove`](#remove) 操作.  (在客户端和服务端，这个暂存器都是使用
Minimongo实现.)

默认情况，Meteor自动发布每个文档在你的集合,在连接的每一个客户端上。如果要关闭该行为，需要移除
`autopublish` 包:

    $ meteor remove autopublish

如果不想用这种方式可以调用 [`Meteor.publish`](#meteor_publish)
来指定你的集合想要发布哪一部分到哪一个用户。

    // Create a collection called Posts and put a document in it. The
    // document will be immediately visible in the local copy of the
    // collection. It will be written to the server-side database
    // a fraction of a second later, and a fraction of a second
    // after that, it will be synchronized down to any other clients
    // that are subscribed to a query that includes it (see
    // Meteor.subscribe and autopublish)
    Posts = new Meteor.Collection("posts");
    Posts.insert({title: "Hello world", body: "First post"});

    // Changes are visible immediately -- no waiting for a round trip to
    // the server.
    assert(Posts.find().count() === 1);

    // Create a temporary, local collection. It works just like any other
    // collection, but it doesn't send changes to the server, and it
    // can't receive any data from subscriptions.
    Scratchpad = new Meteor.Collection;
    for (var i = 0; i < 10; i++)
      Scratchpad.insert({number: i * 2});
    assert(Scratchpad.find({number: {$lt: 9}}).count() === 5);

如果你指定一个`transform`操作来集合或其任何索引的方法，文档将通过该`transform`方法，在被返回或通过
回调之前。这允许你添加方法或者修改集合的内容。你可以指定 `transform` 中特别实现的方法
`find`, `findOne`, `allow`, or `deny` call.

    // An Animal class that takes a document in its constructor
    Animal = function (doc) {
      _.extend(this, doc);
    };
    _.extend(Animal.prototype, {
      makeNoise: function () {
        console.log(this.sound);
      }
    });

    // Define a Collection that uses Animal as its document
    Animals = new Meteor.Collection("Animals", {
      transform: function (doc) { return new Animal(doc); }
    });

    // Create an Animal and call its makeNoise method
    Animals.insert({name: "raptor", sound: "roar"});
    Animals.findOne({name: "raptor"}).makeNoise(); // prints "roar"

`transform` 函数不能响应式调用。如果你想体那家动态的属性改变到你的对象，使用一个函数，该函数计下值被调用
时间，不计算`transform`的时间。

{{#warning}}
在此版本中， Minimongo 有如下限制:

* `$pull` 只能接收主要类别的选择器.
* `$` 修改后用来匹配数组中的位置不再支持。
* `findAndModify`, 聚合函数，map/reduce 不支持.

所有这些将在以后的版本中解决。对于全部的 Minimongo release 说明, 参见 packages/minimongo/NOTES
{{/warning}}

{{#warning}}
Minimongo 目前没有索引。这是罕见的一个问题，
因为客户端拥有足够多的数据让索引有价值是很不寻常的。
{{/warning}}

{{> api_box find}}

`find` 返回一个游标。它不会直接访问数据库或返回文档。游标提供`fetch`来返回所有匹配的文档，
`map`和`forEach`来遍历所有匹配的文档，`observe` 和 `observeChanges`用来
注册回调，所有匹配的文档改变时候调用。

{{#warning}}
集合游标不是用来查询快照。当数据库在调用`Collections.find`和获取游标的结果或游标读取结果之间
改变时，这些改变可能会也可能不会出现在结果中。
{{/warning}}

游标是一个响应式数据源码。当你第一次检索一个游标文档，并使用`fetch`,`map`,或
`forEach`包含到响应计算中（例如，一个模板或使用
[`autorun`](#deps_autorun)), Meteor将注册一个依赖的基础数据.
任何对集合的改变即在游标中改变文档，都将触发重新计算。要想禁止该行为，传递
`{reactive: false}` 到 `find` 上。

{{> api_box findone}}

相当于 `find(selector, options).fetch()[0]` 并加上选项
`options.limit = 1`.

{{> api_box insert}}

添加一个集合的文档。文档是一个对象，且它的字段可以包含任何EJSON数据类型
(arrays, objects, numbers, strings, `null`, true, and false)的组合.

`insert`会产生一个唯一的ID在你传递的对象上，插入数据库后，并返回ID。当`insert`被
不被信任的客户端调用，它则必须通过[`allow`](#allow) 和 [`deny`](#deny)才被允许。

在服务端，如果你没有提供一个回调，那么`insert`会被阻塞直到数据库承认写入或者抛出
一个异常如果有错误的话。如果你提供回调，`insert`仍然返回直接返回ID。一旦插入完成
(或失败)，回调就被以错误或结果参数调用。在错误情况，`result`是undefined。如果插入
成功，`error`为undefined而`result`则为新文档的ID。

在客户端，` 插入`从来不会被阻塞。如果你没有提供回调且插入到服务端失败，那么Meteor将输出
一条警告到控制台。如果你提供回调，Meteor将调用该回调并以`error`和`result`参数。
在错误的情况，`result`为undefeind。如果插入成功,`error`为undefined而`result`则
为新文档的ID。

例如:

    var groceriesId = Lists.insert({name: "Groceries"});
    Items.insert({list: groceriesId, name: "Watercress"});
    Items.insert({list: groceriesId, name: "Persimmons"});

{{> api_box update}}

修改匹配选择器的文档，根据`modifier`(见
[modifier documentation](#modifiers)).

`update`行为取决于它是否被信任或被不被信任的代码调用。受信任的代码包含服务器的代码
和方法代码。不受信任的包含客户端的代码如时间句柄和浏览器Javascript从控制台.

- 受信任代码可以一次修改多个文档，只要设定`multi`为真，且你能使用任意的
  [Mongo 选择器](#selectors) 来寻找要修改的文档。它绕过任意的访问控制规则
  [`allow`](#allow) 和 [`deny`](#deny)。受影响的文档从`update`回调返回，
  如果你传递回调。

- 未信任的代码只能一次修改一个文档，通过指定的`_id`。这中修改只在检测适应
  [`allow`](#allow) 和 [`deny`](#deny) 规则后才被允许修改。
  受影响的文档数目将被返回到回调。未信任的代码不能执行upserts,除了在不安全模式。

在服务端，如果你没有提供回调，`update`将被阻塞直到数据库承认写入或抛出一个异常。如果你
提供回调，`update`直接返回。一旦更新完成，回调错误参数返回在错误情况下，或者以指定受
影响文档数目为第二个参数当成功更新时候。

在客户端，`update`从不被阻塞。如果没提供回调且在服务端更新失败，那么Meteor将输出一个警告
到控制台。如果提供回调，Meteor将调用该函数，并以一个错误参数如果错误的话，或者以一个指定
受影响文档数目作为第二个参数如果成功更新的话。

客户端例子:

    // When the givePoints button in the admin dashboard is pressed,
    // give 5 points to the current player. The new score will be
    // immediately visible on everyone's screens.
    Template.adminDashboard.events({
      'click .givePoints': function () {
        Players.update(Session.get("currentPlayer"), {$inc: {score: 5}});
      }
    });

服务端例子:

    // Give the "Winner" badge to each user with a score greater than
    // 10. If they are logged in and their badge list is visible on the
    // screen, it will update automatically as they watch.
    Meteor.methods({
      declareWinners: function () {
        Players.update({score: {$gt: 10}},
                       {$addToSet: {badges: "Winner"}},
                       {multi: true});
      }
    });

你可以使用`update`来执行一个Mongo的upsert，只要将设定中的`upsert`设置为真。你
同样可以使用 [`upsert`](#upsert) 方法来执行一个upsert，这样它会返回已插入文档(如果只有一个)
的_id，此外还有受影响文档的数目.

{{> api_box upsert}}

修改匹配的文档，或者插入一个文档在没有文档被修改时。`upsert`类似于调用`update`并将其
`upsert`选项设置为true，除了`upsert`返回的对象包含 `numberAffected`
和 `insertedId`. (`update` 只返回受影响文档的数目.)

{{> api_box remove}}

寻找所有匹配选择器的文档, 并从集合中删除它们。

`remove`的行为取决于它是被受信任的代码还是不受信任的代码调用。受信任的代码包含服务端
代码和方法。不受信任的包含客户端代码如事件句柄和浏览器javascript控制台。

- 受信任的代码能使用任意的 [Mongo选择器](#selectors)来寻找要被删除的文档，且能
  一次删除更多的文档通过匹配多个文档的选择器。它绕过任何的访问控制规则如
  [`allow`](#allow) 和 [`deny`](#deny)。
  移除文档的数目将被返回如果你没有指定回调的话。

  作为一个安全措施，如果选择器漏掉（或未定义），没有文档会被移除。设定选择器为`{}`
  如果你真的想要移除所有文档的话。

- 未信任的代码只能一次移除一个文档，通过指定`_id`。文档只有检测通过
  [`allow`](#allow) 和 [`deny`](#deny) 规则之后才能被移除。 移除的文档
  数目将被返回到回调函数。

在服务端，如果你没有提供回调，那么`remove`将阻塞直到数据库确认已写入并返回移除文档的
数目或抛出异常。如果你提供回调，`remove`直接返回。一旦删除完成，回调将以一个错误对象为
参数，或者成功情况以删除文档数目作为第二个参数。

在服务端，`remove`从来不会被阻塞。如果你没提供回调函数且移除失败，那么Meteor会输出警告到
控制台。如果你提供回调，Meteor调用回调并以一个错误对象作为参数，或者成功情况以删除文档
数目作为第二个参数。

客户端例子:

    // When the remove button is clicked on a chat message, delete
    // that message.
    Template.chat.events({
      'click .remove': function () {
        Messages.remove(this._id);
      }
    });

服务端例子:

    // When the server starts, clear the log, and delete all players
    // with a karma of less than -2.
    Meteor.startup(function () {
      if (Meteor.isServer) {
        Logs.remove({});
        Players.remove({karma: {$lt: -2}});
      }
    });

{{> api_box allow}}

当一个客户端调用`insert`,`update`,或`remove`，集合中的`allow`和[`deny`](#deny)
回调在服务端被调用用来确定写入是否被允许。如果至少一个`allow`回调允许写入，且没有`deny`
回调拒绝写入，那么写入将被允许。

这些检测只有在客户端试图直接写入数据才会运行，例如通过内置事件句柄调用`update`。
服务器代码是被信任的且不需要受`allow`和`deny`限制。这包括调用`Meteor.call`的方法--
我们希望他们做自己的访问检测，而不是依赖于`allow`和`deny`。

你能调用`allow`任意次，且每次都能包含任何的`insert`,`update`和`remove`组合。
这些函数会返回`true`，如果他们认为操作允许。否则返回`false`，或者什么都没有
(`undefined`). 这种情况Meteor将通过任何其他的`allow`规则继续搜索。

可用的回调有:

<dl class="callbacks">
{{#dtdd "insert(userId, doc)"}}
用户`userId`想要插入文档`doc`到集合中。返回`真`如果他被允许。
{{/dtdd}}

{{#dtdd "update(userId, doc, fieldNames, modifier)"}}

用户`userId`想要更新文档`doc`。(`doc`是当前来自数据库的文档版本，没有提供更新)，
返回`true`如果修改通过。

`fieldNames`是想在客户端修改的`doc`字段（顶层）的数组，例如:
`['name',`&nbsp;`'score']`

`modifier`是原始的Mongo修饰语，用于客户端想要的执行；例如，
`{$set: {'name.first': "Alice"}, $inc: {score: 1}}`.

只有Mongo修饰符才能被支持(操作类似`$set`和`$push`)。
如果用户试图替换整个文档而不使用$-modifers,请求将被拒绝在没有检测`allow`函数情况下。

{{/dtdd}}

{{#dtdd "remove(userId, doc)"}}

用户`userId`想要从数据库中移除`doc`，返回`true`如果操作通过。

{{/dtdd}}

</dl>

当调用`update`或`remove` Meteor将默认从数据库获取整个`doc`文档。如果你有一个
很大的文档, 你可能只想要获取指定的用在你函数上的字段. 通过设定`fetch`到一个字段
名字的数组来检索可以达到这个目的。

Example:

    // Create a collection where users can only modify documents that
    // they own. Ownership is tracked by an 'owner' field on each
    // document. All documents must be owned by the user that created
    // them and ownership can't be changed. Only a document's owner
    // is allowed to delete it, and the 'locked' attribute can be
    // set on a document to prevent its accidental deletion.

    Posts = new Meteor.Collection("posts");

    Posts.allow({
      insert: function (userId, doc) {
        // the user must be logged in, and the document must be owned by the user
        return (userId && doc.owner === userId);
      },
      update: function (userId, doc, fields, modifier) {
        // can only change your own documents
        return doc.owner === userId;
      },
      remove: function (userId, doc) {
        // can only remove your own documents
        return doc.owner === userId;
      },
      fetch: ['owner']
    });

    Posts.deny({
      update: function (userId, docs, fields, modifier) {
        // can't change owners
        return _.contains(fields, 'owner');
      },
      remove: function (userId, doc) {
        // can't remove locked documents
        return doc.locked;
      },
      fetch: ['locked'] // no need to fetch 'owner'
    });

如果你从没设定任何的`allow`规则在你的集合中那么所有客户端的写入都将被拒绝，且它可能只能
从服务端代码中写入。这种情况你将必须创建一个方法用来让客户端允许的写入成为可能。你将
通过`Meteor.call`调用这些方法，而非通过客户端的`insert`, `update`, 和 `remove`
直接操作集合.

Meteor也有一个特别的"不安全模式"用来快速制作新应用程序原型。在不安全模式下，如果你
没有设置任何的`allow`或`deny`规则在集合中，那么所有的用户都有完全的写入权限到你的集合。
这个只有在不安全模式下生效。如果你调用`allow`或`deny`在所有集合，甚至
`Posts.allow({})`, 那么访问会被正常检测。新Meteor项目默认开启不安全模式通。要关闭可以
通过运行 `$ meteor remove insecure`.

{{> api_box deny}}

类似于 [`allow`](#allow), 除了它是让你确定写入是否明确拒绝，即使`allow`规则允许
也没用。

当一个客户端试图写入到集合，Meteor服务先会检测集合的`deny`规则。如果没有一个返回真，
那么它才检测集合的`allow`规则。Meteor允许写入只有在没有`deny`返回真且至少一个`allow`
返回真。

<h2 id="meteor_collection_cursor"><span>游标</span></h2>

要创建一个游标，使用[`find`](#find)。想要访问集合通过游标，可使用
[`forEach`](#foreach), [`map`](#map), 或 [`fetch`](#fetch).

{{> api_box cursor_foreach}}

这个接口兼容于
[Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).

当调用自一个响应式计算，`forEach`注册一个依赖到匹配的文档。

Examples:

    // Print the titles of the five top-scoring posts
    var topPosts = Posts.find({}, {sort: {score: -1}, limit: 5});
    var count = 0;
    topPosts.forEach(function (post) {
      console.log("Title of post " + count + ": " + post.title);
      count += 1;
    });

{{> api_box cursor_map}}

这个接口兼容于
[Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).

当调用自一个响应式计算，`map`注册一个依赖到匹配的文档。
<!-- The following is not yet implemented, but users shouldn't assume
     sequential execution anyway because that will break. -->

在服务器端，其他回调可能发生在第一个回调以及功能开始，如果想要严格的按顺序执行，使用`forEach`
替代。

{{> api_box cursor_fetch}}

当调用来自一个响应式计算，`fetch`注册一个依赖到匹配的文档.

{{> api_box cursor_count}}

    // Display a count of posts matching certain criteria. Automatically
    // keep it updated as the database changes.
    var frag = Meteor.render(function () {
      var highScoring = Posts.find({score: {$gt: 10}});
      return "<p>There are " + highScoring.count() + " posts with " +
        "scores greater than 10</p>";
    });
    document.body.appendChild(frag);

不像其他函数，`count`只有在匹配数目的文档注册一个依赖。(对改变或记录文档的更新不会触发
重计算。)

{{> api_box cursor_rewind}}

`forEach`, `map`, 和 `fetch` 在一个游标中只能被调用一次。为了多次访问游标记录， 使用
`rewind`可以重置游标。

{{> api_box cursor_observe}}

建立一个 *实时查询* 来调用回调当查询结果改变时候。回调接收整个受影响文档的内容，而且
包括旧的内容。如果你只想要接收改变的字段，请参见
[`observeChanges`](#observe_changes).

`回调`可以含有一下属性：

<dl class="callbacks">
<dt><span class="name">added(document)</span> <span class="or">or</span></dt>
<dt><span class="name">addedAt(document, atIndex, before)</span></dt>
<dd>
{{#better_markdown}}
一个包含结果集的新`文档`。这个文档出现在`atIndex`位置。它在`_id`为`before`文档的
文档的前面。如果新文档在结果的末尾，`before`则为`null`。
{{/better_markdown}}
</dd>

<dt><span class="name">changed(newDocument, oldDocument)
    <span class="or">or</span></span></dt>
<dt><span class="name">changedAt(newDocument, oldDocument, atIndex)</span></dt>
<dd>
{{#better_markdown}}
之前旧的文档内容变成现在新的内容。改变的文档的位置为`atIndex`。
{{/better_markdown}}
</dd>

<dt><span class="name">removed(oldDocument)</span>
  <span class="or">or</span></dt>
<dt><span class="name">removedAt(oldDocument, atIndex)</span></dt>
<dd>
{{#better_markdown}}
旧的文档不再出现在结果集中。它之前在`atInex`位置。
{{/better_markdown}}
</dd>

{{#dtdd "movedTo(document, fromIndex, toIndex, before)"}}
文档改变其在结果集中的位置，从`fromIndex`到`toIndex`（这是在id为`before`前的文档）。
它当前的内容为`document`。
{{/dtdd}}
</dl>

使用`added`,`changed`,和`removed`在你不关心文档在结果集中的顺序时。他们比
`addedAt`, `changedAt`, 和 `removedAt`更有效果。

在`observe`返回前，`added`(或`addedAt`)将被调用0次或更多次来传递初始化结果查询。

`observe`返回一个实时查询句柄，句柄包含`stop`方法。不加参数调用`stop`可以停止调用回调并移除
查询。**回调将永远执行直到你调用stop。**如果`obserce`通过一个`Deps.autorun`计算器
调用，它则会自动停止当计算器重新运行或者停止。
(如果游标被创建且`reactive`配置为false，那么它只会传递初始化结果且不会调用任何进一步的
毁掉，也不需要再调用`stop`).


{{> api_box cursor_observe_changes}}

建立一个`实时查询`，即在查询结果改变时候调用。相比 [`observe`](#observe),
`observeChanges`只提供新和旧的结果集的不同数据，而不是整个被改变文档的内容。

回掉可能含有一下函数属性：

<dl class="callbacks">
<dt><span class="name">added(id, fields)</span>
  <span class="or">or</span></dt>
<dt><span class="name">addedBefore(id, fields, before)</span></dt>
<dd>
{{#better_markdown}}
A new document entered the result set. It has the `id` and `fields`
specified. `fields` contains all fields of the document excluding the
`_id` field. The new document is before the document identified by
`before`, or at the end if `before` is `null`.
{{/better_markdown}}
</dd>

{{#dtdd "changed(id, fields)"}}
文档标识符`id`已经改变，`fields`包含新的值中改变的字段。如果一个字段从文档中移除，那么
它在`fields`中被设定为`undefined`.
{{/dtdd}}

{{#dtdd "movedBefore(id, before)"}}
文档的表示`id`改变它的位置，在按顺序的结果集中，且现在出现在文档标识符`before`的前面。
{{/dtdd}}

{{#dtdd "removed(id)"}}
The document identified by `id` was removed from the result set.
{{/dtdd}}
</dl>

`observeChanges` 更显著更有效，如果你不使用
`addedBefore` 或 `movedBefore`.

在 `observeChanges` 返回前, `added` (或 `addedBefore`) 将被调用0次或更多次来
传送查询的初始化结果。

`observeChanges`返回一个实时的查询句柄，句柄包含`stop`方法。不加参数调用`stop`可以停止回调
并移除查询。**查询会一直运行知道调用这个`stop`.**

`observeChange`被`Deps.autorun`计算器调用，当计算器重新运行或停止时它会自动停止。
(如果游标被创建病配置`reactive`为false，它将只传递初始结果切不会调用更进一步的回调；
它不需要调用`stop`句柄。)

{{#note}}
不像`observe`，`obseveChanges`不提供绝对的地址信息（也就是，`atIndex`而非`before`位置，
这是为了提高效率。
{{/note}}

例如:

    // Keep track of how many administrators are online.
    var count = 0;
    var query = Users.find({admin: true, onlineNow: true});
    var handle = query.observeChanges({
      added: function (id, user) {
        count++;
        console.log(user.name + " brings the total to " + count + " admins.");
      },
      removed: function () {
        count--;
        console.log("Lost one. We're now down to " + count + " admins.");
      }
    });

    // After five seconds, stop keeping the count.
    setTimeout(function () {handle.stop();}, 5000);

{{> api_box collection_object_id}}

`Meteor.Collection.ObjectID`遵循相同的API作为 [Node MongoDB driver
`ObjectID`](http://mongodb.github.com/node-mongodb-native/api-bson-generated/objectid.html)
. 注意你必须使用`euqals`方法 (或 [`EJSON.equals`](#ejson_equals)) 来比较他们；
 `===` 操作将不起作用.如果你写的代码需要处理`_id`字段，该字段可能是字符串或者`ObjectID`, 请使用
[`EJSON.equals`](#ejson_equals) 代替 `===` 来比较他们。

{{#note}}
  Meteor创建的`ObjectID`值不会对`getTimestamp`方法给出有意义的答案，因为Meteor当前
  创建它们完全是通过随机的。
{{/note}}

{{#api_box_inline selectors}}

在最简单的形式，一个选择器只是匹配一个文档的一组键值：

    // Matches all documents where deleted is false
    {deleted: false}

    // Matches all documents where the name and cognomen are as given
    {name: "Rhialto", cognomen: "the Marvelous"}

    // Matches every document
    {}

不过它可以包含更复杂的测试：

    // Matches documents where age is greater than 18
    {age: {$gt: 18}}

    // Also matches documents where tags is an array containing "popular"
    {tags: "popular"}

    // Matches documents where fruit is one of three possibilities
    {fruit: {$in: ["peach", "plum", "pear"]}}

见 [完整的文档](http://www.mongodb.org/display/DOCS/Advanced+Queries).

{{/api_box_inline}}

{{#api_box_inline modifiers}}

修饰符是一个对象用来描述如何更新文档改变它的一些字段。例如：

    // Set the 'admin' property on the document to true
    {$set: {admin: true}}

    // Add 2 to the 'votes' property, and add "Traz"
    // to the end of the 'supporters' array
    {$inc: {votes: 2}, $push: {supporters: "Traz"}}

但是如果修饰符不包含任何的$-操作符，那么它将被解释为一个文本文档，且完全替代为之前的数据库。
(文本文档目前不被['allow'](#allow)支持.

    // Find the document with id "123", and completely replace it.
    Users.update({_id: "123"}, {name: "Alice", friends: ["Bob"]});

参见 [更详细的修饰符的解释](http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations).

{{/api_box_inline}}

{{#api_box_inline sortspecifiers}}

排序可以指定几种不同的语法方法：

    // All of these do the same thing (sort in ascending order by
    // key "a", breaking ties in descending order of key "b")

    [["a", "asc"], ["b", "desc"]]
    ["a", ["b", "desc"]]
    {a: 1, b: -1}

最后一种形式只有工作在你的javascript保存键值的顺序到你的对象中。要做更多，就得花更多
时间，不过这由你来定。

{{/api_box_inline}}

{{#api_box_inline fieldspecifiers}}

查询能指定一个特别的字段来从结果对象中包含或排除。

为了排除字段从结果集中，字段必须指定为一个字典，字典的键是字段的名字，值为`0`.

    // Users.find({}, {fields: {password: 0, hash: 0}})

为了返回一个只包含特殊字段的独享，使用`1`来作为值。`_id`字段仍然会包含在结果中。

    // Users.find({}, {fields: {firstname: 1, lastname: 1}})

不可能混合包含和排除两种方式(除了`_id`是默认包含或者明切排除)。字段操作如`$`
和`$elemMatch`在客户端上不可用。

更进阶的例子:

    Users.insert({ alterEgos: [{ name: "Kira", alliance: "murderer" },
                               { name: "L", alliance: "police" }],
                   name: "Yagami Light" });

    Users.findOne({}, { fields: { 'alterEgos.name': 1, _id: 0 } });

    // returns { alterEgos: [{ name: "Kira" }, { name: "L" }] }

See <a href="http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection">
the MongoDB docs</a> for details of the nested field rules and array behavior.

{{/api_box_inline}}

<h2 id="session"><span>会话</span></h2>

`会话`提供一个全局的对象在客户端，你可以用来存储任意的键-值形式。使用它来存储东西就像
当前在一个列表中选定选项。

会话最特别的地方就是响应式。如果你从一个内置模板中调用
[`Session.get`](#session_get)`("currentList")`,
模板会自动重新渲染当
[`Session.set`](#session_set)`("currentList", x)`被调用。

{{> api_box set}}

例如:

    Deps.autorun(function () {
      Meteor.subscribe("chat-history", {room: Session.get("currentRoomId")});
    });

    // Causes the function passed to Deps.autorun to be re-run, so
    // that the chat-history subscription is moved to the room "home".
    Session.set("currentRoomId", "home");

{{> api_box setDefault}}

这在初始化代码时非常有用，这是为了避免每次都重新初始化会话.

{{> api_box get}}

例如:

    Session.set("enemy", "Eastasia");
    var frag = Meteor.render(function () {
      return "<p>We've always been at war with " +
        Session.get("enemy") + "</p>";
    });

    // Page will say "We've always been at war with Eastasia"
    document.body.append(frag);

    // Page will change to say "We've always been at war with Eurasia"
    Session.set("enemy", "Eurasia");

{{> api_box equals}}

如果值是一个标量，那么两个表达式做相同的事情：

    (1) Session.get("key") === value
    (2) Session.equals("key", value)

... 但是第二个会更好。它触发较少的模板重绘，来提高你的应用程序性能。

例如:

    <template name="postsView">
    {{dstache}}! Show a dynamically updating list of items. Let the user click on an
        item to select it. The selected item is given a CSS class so it
        can be rendered differently. }}

    {{dstache}}#each posts}}
      {{dstache}}> postItem }}
    {{dstache}}/each}}
    </{{! }}template>

    <template name="postItem">
      <div class="{{dstache}}postClass}}">{{dstache}}title}}</div>
    </{{! }}template>

    ///// in JS file
    Template.postsView.posts = function() {
      return Posts.find();
    };

    Template.postItem.postClass = function() {
      return Session.equals("selectedPost", this._id) ?
        "selected" : "";
    };

    Template.postItem.events({
      'click': function() {
        Session.set("selectedPost", this._id);
      }
    });

    // Using Session.equals here means that when the user clicks
    // on an item and changes the selection, only the newly selected
    // and the newly unselected items are re-rendered.
    //
    // If Session.get had been used instead of Session.equals, then
    // when the selection changed, all the items would be re-rendered.

如果会话值为对象或数组，你不能使用 `Session.equals`; 你可以使用 `underscore`
包并写入 `_.isEqual(Session.get(key), value)` 来替代。



<h2 id="accounts_api"><span>账户</span></h2>

Meteor的账户系统建立在`userId`上，并提供
[`publish`](#publish_userId)  [`methods`](#method_userId) 方法.
核心包在数据库引入了用户文档存储的概念, 切扩展包添加了
[安全密码验证](#accounts_passwords), [整合第三方登陆系统](#meteor_loginwithexternalservice), and a [pre-built user
interface](#accountsui).

基础的登陆系统是一个`accounts-base`包，但是应用程序通常需要包含自动包含一个登陆服务包:
`accounts-password`, `accounts-facebook`,
`accounts-github`, `accounts-google`, `accounts-meetup`,
`accounts-twitter`, 或 `accounts-weibo`.


{{> api_box user}}

检索当前用户的用户记录，通过 [`Meteor.users`](#meteor_users) 集合。

在客户端，这将是从服务器发布的文档（其他字段在客户端可能不能用）字段的子集.
默认服务端发布 `username`, `emails`, 和
`profile`. 见 [`Meteor.users`](#meteor_users) 如果想包含更多字段的话。

{{> api_box userId}}

{{> api_box users}}

这个集合包含一个每个注册用户的一个文档。这是用户文档的例子：

    {
      _id: "bbca5d6a-2156-41c4-89da-0329e8c99a4f",  // Meteor.userId()
      username: "cool_kid_13", // unique name
      emails: [
        // each email address can only belong to one user.
        { address: "cool@example.com", verified: true },
        { address: "another@different.com", verified: false }
      ],
      createdAt: Wed Aug 21 2013 15:16:52 GMT-0700 (PDT),
      profile: {
        // The profile is writable by the user by default.
        name: "Joe Schmoe"
      },
      services: {
        facebook: {
          id: "709050", // facebook id
          accessToken: "AAACCgdX7G2...AbV9AZDZD"
        },
        resume: {
          loginTokens: [
            { token: "97e8c205-c7e4-47c9-9bea-8e2ccc0694cd",
              when: 1349761684048 }
          ]
        }
      }
    }

用户文档包含任何你想要存储关于用户的数据。Meteor特别提供一下字段：

- `username`: a unique String identifying the user.
- `emails`: an Array of Objects with keys `address` and `verified`;
  an email address may belong to at most one user. `verified` is
  a Boolean which is true if the user has [verified the
  address](#accounts_verifyemail) with a token sent over email.
- `createdAt`: the Date at which the user document was created.
- `profile`: an Object which (by default) the user can create
  and update with any data.
- `services`: an Object containing data used by particular
  login services. For example, its `reset` field contains
  tokens used by [forgot password](#accounts_forgotpassword) links,
  and its `resume` field contains tokens used to keep you
  logged in between sessions.

像所有的 [Meteor.Collection](#collections) 集合, 你能在服务端访问所有文档，
但是只有指定的在服务端发布的才能在客户端可用。

默认情况，当前用户的 `username`, `emails`, `profile` 会被发送的客户端。你可以发布
更多扩展的字段在你的当前用户:

    Meteor.publish("userData", function () {
      return Meteor.users.find({_id: this.userId},
                               {fields: {'other': 1, 'things': 1}});
    });

如果自动发布包被安装，系统中关于所有用户的信息将被发布到所有客户端。它包含
`username`, `profile`, 和任何公用的 `服务` (例如 `services.facebook.id`,
`services.twitter.screenName`). 此外，当使用自动发布更多信息将以当前登陆的
用户发布，包含它的访问tokens。这允许从客户端直接调用API，只要服务器允许这样做。

用户默认允许配置它的`profile`字段，只要通过
[`Accounts.createUser`](#accounts_createuser) 和
`Meteor.users.update` 修改. 如果要允许用户编辑扩展字段，使用
[`Meteor.users.allow`](#allow)可禁止用户使用任何的修改到用户文档：

    Meteor.users.deny({update: function () { return true; }});


{{> api_box loggingIn}}

例如, [`accounts-ui` 包](#accountsui)
使用它来显示一个动画在用户请求被处理的时候。

{{> api_box logout}}

{{> api_box logoutOtherClients}}

例如，当在用户的浏览器中调用时，浏览器会保持连接状态，但是任何其他的浏览器或者DDP客户端
登陆该用户都会被登出。

{{> api_box loginWithPassword}}

这个函数由 `accounts-password` 包提供。见
[Passwords](#accounts_passwords) 会话.


{{> api_box loginWithExternalService}}

这个函数可用于启动一个扩展服务的登陆进程
(例如: Facebook, Google, 等等),
使用了 OAuth.
当他们调用时, 他们打开一个下拉窗来加载提供者的登陆页面.一旦用户被登陆，下拉窗就关闭然后
Meteor客户端登陆Meteor服务器并或者这些扩展服务提供的信息。

<a id="requestpermissions" name="requestpermissions" />

除了识别用户到你的应用程序，一些服务还提供API来允许你代表用户来执行行为。为了请求用户的
特定权限，传递 `requestPermissions` 选项来登陆函数。这会导致用户在弹出的对话框
出现一个额外的页面来访问他们的数据。用户的
 `accessToken` -- 以权限访问服务器的API，会存储在服务端的用户文档的字段中。
 对于 `requestPermissions` 支持的值不同于每个登陆服务，它会记录在各自的网站:

- Facebook: <http://developers.facebook.com/docs/authentication/permissions/>
- GitHub: <http://developer.github.com/v3/oauth/#scopes>
- Google: <https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter>
- Meetup: <http://www.meetup.com/meetup_api/auth/#oauth2-scopes>
- Twitter, Weibo: `requestPermissions` currently not supported

扩展的登陆服务通常在使用前需要注册和配置你的应用程序。最简单的方式是使用
[`accounts-ui` 包](#accountsui), 该包可以一步一步指导你配置每个服务。然而，
数据也可以被手动的通过 `Accounts.loginServiceConfiguration` 集合进入。例如；

    // first, remove configuration entry in case service is already configured
    Accounts.loginServiceConfiguration.remove({
      service: "weibo"
    });
    Accounts.loginServiceConfiguration.insert({
      service: "weibo",
      clientId: "1292962797",
      secret: "75a730b58f5691de5522789070c319bc"
    });


每个扩展的服务拥有它自己的登陆提供包和登陆函数。例如为了支持GitHub登陆，运行
`$ meteor add accounts-github` 并使用 `Meteor.loginWithGithub` 函数:

    Meteor.loginWithGithub({
      requestPermissions: ['user', 'public_repo']
    }, function (err) {
      if (err)
        Session.set('errorMessage', err.reason || 'Unknown error');
    });



{{> api_box currentUser}}
{{> api_box loggingInTemplate}}
{{> api_box accounts_config}}
{{> api_box accounts_ui_config}}

例如:

    Accounts.ui.config({
      requestPermissions: {
        facebook: ['user_likes'],
        github: ['user', 'repo']
      },
      requestOfflineToken: {
        google: true
      },
      passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL'
    });

{{> api_box accounts_validateNewUser}}

这个可以被多次调用。如果任何的函数返回`false`或抛出异常，新的用户创建将被终止。如果要设定
一个特定的错误信息（会被显示到
be displayed by [`accounts-ui`](#accountsui)),
抛出一个 [`Meteor.Error`](#meteor_error)异常.

例如:

    // Validate username, sending a specific error message on failure.
    Accounts.validateNewUser(function (user) {
      if (user.username && user.username.length >= 3)
        return true;
      throw new Meteor.Error(403, "Username must have at least 3 characters");
    });
    // Validate username, without a specific error message.
    Accounts.validateNewUser(function (user) {
      return user.username !== "root";
    });

{{> api_box accounts_onCreateUser}}

使用这个当你需要做更多事情而不是简单的接收或者拒绝新的用户创建。通过这个函数你可以通过编程
控制新的用户文档的内容。

这个你传递的函数将以两个参数被调用: `options` 和 `user`.
`options`参数来自 [`Accounts.createUser`](#accounts_createuser) 一种基于密码的
用户，或者来自一个扩展的服务登陆流程。`options`可能会来自一个不被信任的客户端所以一定要验证
任何的值你从它获取到的。`user`参数被创建在服务端，它包含一个推荐的用户对象，对象包含所有自动
生成的字段，在用户要求登陆时。

函数应该返回一个用户文档(不管是一次传入或者新创建的对象)，任何修改都需要这个文档。返回的文档
直接插入到 [`Meteor.users`](#meteor_users) 集合中.

默认创建的用户对象只是简单的服务 `options.profile` 到新的用户文档中。调用
`onCreateUser` 可覆盖默认的钩子。这个只能被调用一次。

例如:

<!-- XXX replace d6 with _.random once we have underscore 1.4.2 -->

    // Support for playing D&D: Roll 3d6 for dexterity
    Accounts.onCreateUser(function(options, user) {
      var d6 = function () { return Math.floor(Random.fraction() * 6) + 1; };
      user.dexterity = d6() + d6() + d6();
      // We still want the default hook's 'profile' behavior.
      if (options.profile)
        user.profile = options.profile;
      return user;
    });


<h2 id="accounts_passwords"><span>密码</span></h2>

`accounts-password` 包含一个完整的系统用来使用基于密码的验证。除了基础的用户名和
密码登陆程序，它还提供email登陆，包括地址验证和emails密码恢复。

不像大部分的web应用，Meteor客户端不直接发送用户的密码到客户但。它使用
[安全远程密码协议](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)
来确保服务端无法看到用户的文本密码。这样能防止密码被泄漏如果服务端的数据库被攻破。

为了给你的应用程序添加密码支持，运行 `$ meteor add accounts-password`.
你可以通过以下函数创建你自己的用户接口,或者使用 [`accounts-ui` 包](#accountsui)
来包含一个turn-key用户接口实现这种密码式登陆。


{{> api_box accounts_createUser}}

在客户端，这个函数被用来记录一个新的用户创建的成功完成。在服务端，它返回新创建的用户的id。

在客户端，你必须发送`password`或者`username`或`email`其中的一个，这样就有足够的信息来
保证用户再次登陆。在服务端，你可以发送这些选项的子集，但是用户不能登陆除非它拥有标识和一个
密码。

为了创建一个账户而不使用密码在服务端且仍然让用户选择自己的密码，调用`createUser`包含
一个`email`选项，然后调用
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).
这会发送给用户邮箱一个连接来设定他们初始化的密码。

默认`profile`选项被直接添加一个新的用户文档。为了覆盖这些行为，可使用
[`Accounts.onCreateUser`](#accounts_oncreateuser).

这个函数只是用来使用密码创建用户。外部的服务登陆流程不能使用这个函数。


{{> api_box accounts_changePassword}}

{{> api_box accounts_forgotPassword}}

这会出发一个调用到服务器的
 [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)
. 传递用户在邮箱中接受到的token到
[`Accounts.resetPassword`](#accounts_resetpassword)
可以完成密码重设程序。

如果你使用
[`accounts-ui` 包](#accountsui),
它会自动处理。否则，你必须要自己去提示用户输入新密码并调用 `resetPassword`。

{{> api_box accounts_resetPassword}}

这个函数接收由
[`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)
和
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail)
生成的token。

{{> api_box accounts_setPassword}}

{{> api_box accounts_verifyEmail}}

这个函数接受由
[`Accounts.sendVerificationEmail`](#accounts_sendverificationemail)
生成的token。它设定了
`emails.verified` 字段在用户的记录中。

{{> api_box accounts_sendResetPasswordEmail}}

该邮箱的token必须发送到
[`Accounts.resetPassword`](#accounts_resetpassword).

要自定义发送到邮箱的内容，见
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendEnrollmentEmail}}

该邮箱的token必须发送到
[`Accounts.resetPassword`](#accounts_resetpassword).

要自定义发送到邮箱的内容，见
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendVerificationEmail}}

The token in this email should be passed
to [`Accounts.verifyEmail`](#accounts_verifyemail).

该邮箱的token必须发送到
[`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_emailTemplates}}

这是一个对象包含一些字段用来生成由
`sendResetPasswordEmail`, `sendEnrollmentEmail`,
和 `sendVerificationEmail`发送的邮箱文本。

通过指定以下选项来覆盖对象的字段：

- `from`: A `String` with an [RFC5322](http://tools.ietf.org/html/rfc5322) From
   address. By default, the email is sent from `no-reply@meteor.com`. If you
   wish to receive email from users asking for help with their account, be sure
   to set this to an email address that you can receive email at.
- `siteName`: The public name of your application. Defaults to the DNS name of
   the application (eg: `awesome.meteor.com`).
- `resetPassword`: An `Object` with two fields:
 - `resetPassword.subject`: A `Function` that takes a user object and returns
   a `String` for the subject line of a reset password email.
 - `resetPassword.text`: A `Function` that takes a user object and a url, and
   returns the body text for a reset password email.
- `enrollAccount`: Same as `resetPassword`, but for initial password setup for
   new accounts.
- `verifyEmail`: Same as `resetPassword`, but for verifying the users email
   address.


例如:

    Accounts.emailTemplates.siteName = "AwesomeSite";
    Accounts.emailTemplates.from = "AwesomeSite Admin <accounts@example.com>";
    Accounts.emailTemplates.enrollAccount.subject = function (user) {
        return "Welcome to Awesome Town, " + user.profile.name;
    };
    Accounts.emailTemplates.enrollAccount.text = function (user, url) {
       return "You have been selected to participate in building a better future!"
         + " To activate your account, simply click the link below:\n\n"
         + url;
    };


<h2 id="templates_api"><span>模板</span></h2>

一个模板通过声明类似
`<{{! }}template name="foo"> ... </{{!
}}template>` 可以被`Template.foo`访问，并返回一个HTML字符串在被调用的时候。

一个相同的模板可能在页面中出现很多次，这些出现都被称作模板实例。模板实例
拥有一个生命周期：被创建，添加入文档，然后从文档中拿出，最后销毁。Meteor
为你管理这些阶段，包括决定什么时候模板实例被移除,替换, 清理掉。你可以关联数据到一个模板
实例，当它在文档中时候你可以访问它的DOM节点。

此外, Meteor会维持一个模板实例和它的状态，甚至它被包装成HTML并重新渲染到新的DOM借点。
只要模板的调用的结构是相同的，Meteor将不考虑已经创建或销毁的任何实例。你可以请求同一
个被保留的DOM节点，以及使用 `preserve` 和 `constant`.

有很多回调和指令可以指定在已命名的模板中，同样可以使用于所有模板的实例。它们会在下面描述。

{{> api_box template_call}}

When called inside a template helper, the body of `Meteor.render`, or
other settings where reactive HTML is being generated, the resulting
HTML is annotated so that it renders as reactive DOM elements.
Otherwise, the HTML is unadorned and static.


{{> api_box template_rendered}}

This callback is called once when an instance of Template.*myTemplate* is
rendered into DOM nodes and put into the document for the first time, and again
each time any part of the template is re-rendered.

In the body of the callback, `this` is a [template
instance](#template_inst) object that is unique to this occurrence of
the template and persists across re-renderings.  Use the `created` and
`destroyed` callbacks to perform initialization or clean-up on the
object.

{{> api_box template_created}}

This callback is called when an invocation of *myTemplate* represents
a new occurrence of the template and not a re-rendering of an existing
template instance.  Inside the callback, `this` is the new [template
instance](#template_inst) object.  Properties you set on this object
will be visible from the `rendered` and `destroyed` callbacks and from
event handlers.

This callback fires once and is the first callback to fire.  Every
`created` has a corresponding `destroyed`; that is, if you get a
`created` callback with a certain template instance object in `this`,
you will eventually get a `destroyed` callback for the same object.

{{> api_box template_destroyed}}

This callback is called when an occurrence of a template is taken off
the page for any reason and not replaced with a re-rendering.  Inside
the callback, `this` is the [template instance](#template_inst) object
being destroyed.

This callback is most useful for cleaning up or undoing any external
effects of `created`.  It fires once and is the last callback to fire.


{{> api_box template_events}}

Declare event handers for instances of this template. Multiple calls add
new event handlers in addition to the existing ones.

See [Event Maps](#eventmaps) for a detailed description of the event
map format and how event handling works in Meteor.

{{> api_box template_helpers}}

Each template has a local dictionary of helpers that are made available to it,
and this call specifies helpers to add to the template's dictionary.

Example:

    Template.myTemplate.helpers({
      foo: function () {
        return Session.get("foo");
      }
    });

In Handlebars, this helper would then be invoked as `{{dstache}}foo}}`.

The following syntax is equivalent, but won't work for reserved property
names:

    Template.myTemplate.foo = function () {
      return Session.get("foo");
    };

{{> api_box template_preserve}}

You can "preserve" a DOM element during re-rendering, leaving the
existing element in place in the document while replacing the
surrounding HTML.  This means that re-rendering a template need not
disturb text fields, iframes, and other sensitive elements it
contains.  The elements to preserve must be present both as nodes in
the old DOM and as tags in the new HTML.  Meteor will patch the DOM
around the preserved elements.

{{#note}}
By default, new Meteor apps automatically include the
`preserve-inputs` package.  This preserves all elements of type
`input`, `textarea`, `button`, `select`, and `option` that have unique
`id` attributes or that have `name` attributes that are unique within
an enclosing element with an `id` attribute.  To turn off this default
behavior, simply remove the `preserve-inputs` package.
{{/note}}

Preservation is useful in a variety of cases where replacing a DOM
element with an identical or modified element would not have the same
effect as retaining the original element.  These include:

* Input text fields and other form controls
* Elements with CSS animations
* Iframes
* Nodes with references kept in JavaScript code

If you want to preserve a whole region of the DOM, an element and its
children, or nodes not rendered by Meteor, use a [constant
region](#constant) instead.

To preserve nodes, pass a list of selectors, each of which should match
at most one element in the template.  When the template is re-rendered,
the selector is run on the old DOM and the new DOM, and Meteor will
reuse the old element in place while working in any HTML changes around
it.

A second form of `preserve` takes a labeling function for each selector
and allows the selectors to match multiple nodes. The node-labeling
function takes a node and returns a label string that is unique for each
node, or `false` to exclude the node from preservation.

For example, to preserve all `<input>` elements with ids in template 'foo', use:

    Template.foo.preserve({
      'input[id]': function (node) { return node.id; }
    });

Selectors are interpreted as rooted at the top level of the template.
Each occurrence of the template operates independently, so the selectors
do not have to be unique on the entire page, only within one occurrence
of the template.  Selectors will match nodes even if they are in
sub-templates.

Preserving a node does *not* preserve its attributes or contents. They
will be updated to reflect the new HTML. Text in input fields is not
preserved unless the input field has focus, in which case the cursor and
selection are left intact. Iframes retain their navigation state and
animations continue to run as long as their parameters haven't changed.

There are some cases where nodes can not be preserved because of
constraints inherent in the DOM API. For example, an element's tag name
can't be changed, and it can't be moved relative to its parent or other
preserved nodes.  For this reason, nodes that are re-ordered or
re-parented by an update will not be preserved.

{{#note}}
Previous versions of Meteor had an implicit page-wide `preserve`
directive that labeled nodes by their "id" and "name" attributes.
This has been removed in favor of the explicit, opt-in mechanism.
{{/note}}


<h2 id="template_inst"><span>Template instances</span></h2>

A template instance object represents an occurrence of a template in
the document.  It can be used to access the DOM and it can be
assigned properties that persist across page re-renderings.

Template instance objects are found as the value of `this` in the
`created`, `rendered`, and `destroyed` template callbacks and as an
argument to event handlers.

In addition to the properties and functions described below, you can
assign additional properties of your choice to the object.  Property names
starting with `_` are guaranteed to be available for your use.  Use
the `created` and `destroyed` callbacks to perform initialization or
clean-up on the object.

You can only access `findAll`, `find`, `firstNode`, and `lastNode`
from the `rendered` callback and event handlers, not from `created`
and `destroyed`, because they require the template instance to be
in the DOM.

{{> api_box template_findAll}}

Returns an array of DOM elements matching `selector`.

The template instance serves as the document root for the selector. Only
elements inside the template and its sub-templates can match parts of
the selector.

{{> api_box template_find}}

Returns one DOM element matching `selector`, or `null` if there are no
such elements.

The template instance serves as the document root for the selector. Only
elements inside the template and its sub-templates can match parts of
the selector.

{{> api_box template_firstNode}}

The two nodes `firstNode` and `lastNode` indicate the extent of the
rendered template in the DOM.  The rendered template includes these
nodes, their intervening siblings, and their descendents.  These two
nodes are siblings (they have the same parent), and `lastNode` comes
after `firstNode`, or else they are the same node.

{{> api_box template_lastNode}}

{{> api_box template_data}}

This property provides access to the data context at the top level of
the template.  It is updated each time the template is re-rendered.
Access is read-only and non-reactive.


{{> api_box render}}

`Meteor.render` creates a `DocumentFragment` (a sequence of DOM nodes)
that automatically updates in realtime. Most Meteor apps don't need to
call this directly; they use templates and Meteor handles the rendering.

Pass in `htmlFunc`, a function that returns an HTML
string. `Meteor.render` calls the function and turns the output into
DOM nodes. Meanwhile, it tracks the data that was used when `htmlFunc`
ran, and automatically wires up callbacks so that whenever any of the
data changes, `htmlFunc` is re-run and the DOM nodes are updated in
place.

You may insert the returned `DocumentFragment` directly into the DOM
wherever you would like it to appear. The inserted nodes will continue
to update until they are taken off the screen. Then they will be
automatically cleaned up. For more details about clean-up, see
[`Deps.flush`](#deps_flush).

`Meteor.render` tracks the data dependencies of `htmlFunc` by running
it in a reactive computation, so it can respond to changes in any reactive
data sources used by that function. For more information, or to learn
how to make your own reactive data sources, see
[Reactivity](#reactivity).

Example:

    // Client side: show the number of players online.
    var frag = Meteor.render(function () {
      return "<p>There are " + Players.find({online: true}).count() +
        " players online.</p>";
    });
    document.body.appendChild(frag);

    // Server side: find all players that have been idle for a while,
    // and mark them as offline. The count on the screen will
    // automatically update on all clients.
    Players.update({idleTime: {$gt: 30}}, {$set: {online: false}});

{{> api_box renderList}}

Creates a `DocumentFragment` that automatically updates as the results
of a database query change. Most Meteor apps use `{{dstache}}#each}}` in
a template instead of calling this directly.

`renderList` is more efficient than using `Meteor.render` to render HTML
for a list of documents.  For example, if a new document is created in
the database that matches the query, a new item will be rendered and
inserted at the appropriate place in the DOM without re-rendering the
other elements.  Similarly, if a document changes position in a sorted
query, the DOM nodes will simply be moved and not re-rendered.

`docFunc` is called as needed to generate HTML for each document.  If
you provide `elseFunc`, then whenever the query returns no results, it
will be called to render alternate content. You might use this to show
a message like "No records match your query."

Each call to `docFunc` or `elseFunc` is run in its own reactive
computation so that if it has other external data dependencies, it will be
individually re-run when the data changes.

Example:

    // List the titles of all of the posts that have the tag
    // "frontpage". Keep the list updated as new posts are made, as tags
    // change, etc.  Display the selected post differently.
    var frag = Meteor.renderList(
      Posts.find({tags: "frontpage"}),
      function(post) {
        var style = Session.equals("selectedId", post._id) ? "selected" : "";
        // A real app would need to quote/sanitize post.name
        return '<div class="' + style + '">' + post.name + '</div>';
      });
    document.body.appendChild(frag);

    // Select a post.  This will cause only the selected item and the
    // previously selected item to update.
    var somePost = Posts.findOne({tags: "frontpage"});
    Session.set("selectedId", somePost._id);


{{#api_box_inline eventmaps}}

Several functions take event maps. An event map is an object where
the properties specify a set of events to handle, and the values are
the handlers for those events. The property can be in one of several
forms:

<dl>
{{#dtdd "<em>eventtype</em>"}}
Matches a particular type of event, such as 'click'.
{{/dtdd}}

{{#dtdd "<em>eventtype selector</em>"}}
Matches a particular type of event, but only when it appears on
an element that matches a certain CSS selector.
{{/dtdd}}

{{#dtdd "<em>event1, event2</em>"}}
To handle more than one type of event with the same function, use a
comma-separated list.
{{/dtdd}}
</dl>

The handler function receives two arguments: `event`, an object with
information about the event, and `template`, a [template
instance](#template_inst) for the template where the handler is
defined.  The handler also receives some additional context data in
`this`, depending on the context of the current element handling the
event.  In a Handlebars template, an element's context is the
Handlebars data context where that element occurs, which is set by
block helpers such as `#with` and `#each`.

Example:

    {
      // Fires when any element is clicked
      'click': function (event) { ... },

      // Fires when any element with the 'accept' class is clicked
      'click .accept': function (event) { ... },

      // Fires when 'accept' is clicked, or a key is pressed
      'keydown, click .accept': function (event) { ... }
    }

Most events bubble up the document tree from their originating
element.  For example, `'click p'` catches a click anywhere in a
paragraph, even if the click originated on a link, span, or some other
element inside the paragraph.  The originating element of the event
is available as the `target` property, while the element that matched
the selector and is currently handling it is called `currentTarget`.

    {
      'click p': function (event) {
        var paragraph = event.currentTarget; // always a P
        var clickedElement = event.target; // could be the P or a child element
      }
    }

If a selector matches multiple elements that an event bubbles to, it
will be called multiple times, for example in the case of `'click
div'` or `'click *'`.  If no selector is given, the handler
will only be called once, on the original target element.

The following properties and methods are available on the event object
passed to handlers:

<dl class="objdesc">
{{#dtdd name="type" type="String"}}
The event's type, such as "click", "blur" or "keypress".
{{/dtdd}}

{{#dtdd name="target" type="DOM Element"}}
The element that originated the event.
{{/dtdd}}

{{#dtdd name="currentTarget" type="DOM Element"}}
The element currently handling the event.  This is the element that
matched the selector in the event map.  For events that bubble, it may
be `target` or an ancestor of `target`, and its value changes as the
event bubbles.
{{/dtdd}}

{{#dtdd name="which" type="Number"}}
For mouse events, the number of the mouse button (1=left, 2=middle, 3=right).
For key events, a character or key code.
{{/dtdd}}

{{#dtdd "stopPropagation()"}}
Prevent the event from propagating (bubbling) up to other elements.
Other event handlers matching the same element are still fired, in
this and other event maps.
{{/dtdd}}

{{#dtdd "stopImmediatePropagation()"}}
Prevent all additional event handlers from being run on this event,
including other handlers in this event map, handlers reached by
bubbling, and handlers in other event maps.
{{/dtdd}}

{{#dtdd "preventDefault()"}}
Prevents the action the browser would normally take in response to this
event, such as following a link or submitting a form.  Further handlers
are still called, but cannot reverse the effect.
{{/dtdd}}

{{#dtdd "isPropagationStopped()"}}
Returns whether `stopPropagation()` has been called for this event.
{{/dtdd}}

{{#dtdd "isImmediatePropagationStopped()"}}
Returns whether `stopImmediatePropagation()` has been called for this event.
{{/dtdd}}

{{#dtdd "isDefaultPrevented()"}}
Returns whether `preventDefault()` has been called for this event.
{{/dtdd}}
</dl>

Returning `false` from a handler is the same as calling
both `stopImmediatePropagation` and `preventDefault` on the event.

Event types and their uses include:

<dl class="objdesc">
{{#dtdd "<code>click</code>"}}
Mouse click on any element, including a link, button, form control, or div.
Use `preventDefault()` to prevent a clicked link from being followed.
Some ways of activating an element from the keyboard also fire `click`.
{{/dtdd}}

{{#dtdd "<code>dblclick</code>"}}
Double-click.
{{/dtdd}}

{{#dtdd "<code>focus, blur</code>"}}
A text input field or other form control gains or loses focus.  You
can make any element focusable by giving it a `tabindex` property.
Browsers differ on whether links, checkboxes, and radio buttons are
natively focusable.  These events do not bubble.
{{/dtdd}}

{{#dtdd "<code>change</code>"}}
A checkbox or radio button changes state.  For text fields, use
`blur` or key events to respond to changes.
{{/dtdd}}

{{#dtdd "<code>mouseenter, mouseleave</code>"}} The pointer enters or
leaves the bounds of an element.  These events do not bubble.
{{/dtdd}}

{{#dtdd "<code>mousedown, mouseup</code>"}}
The mouse button is newly down or up.
{{/dtdd}}

{{#dtdd "<code>keydown, keypress, keyup</code>"}}
The user presses a keyboard key.  `keypress` is most useful for
catching typing in text fields, while `keydown` and `keyup` can be
used for arrow keys or modifier keys.
{{/dtdd}}

{{#dtdd "<code>tap</code>"}} Tap on an element.  On touch-enabled
devices, this is a replacement to `click` that fires immediately.
These events are synthesized from `touchmove` and `touchend`.
{{/dtdd}}

</dl>

Other DOM events are available as well, but for the events above,
Meteor has taken some care to ensure that they work uniformly in all
browsers.

{{/api_box_inline}}



{{#api_box_inline constant}}

You can mark a region of a template as "constant" and not subject to
re-rendering using the
`{{dstache}}#constant}}...{{dstache}}/constant}}` block helper.
Content inside the `#constant` block helper is preserved exactly as-is
even if the enclosing template is re-rendered.  Changes to other parts
of the template are patched in around it in the same manner as
`preserve`.  Unlike individual node preservation, a constant region
retains not only the identities of its nodes but also their attributes
and contents.  The contents of the block will only be evaluated once
per occurrence of the enclosing template.

Constant regions allow non-Meteor content to be embedded in a Meteor
template.  Many third-party widgets create and manage their own DOM
nodes programmatically. Typically, you put an empty element in your
template, which the widget or library will then populate with
children. Normally, when Meteor re-renders the enclosing template it
would remove the new children, since the template says it should be
empty. If the container is wrapped in a `#constant` block, however, it
is left alone; whatever content is currently in the DOM remains.

{{#note}}
Constant regions are intended for embedding non-Meteor content.
Event handlers and reactive dependencies don't currently work
correctly inside constant regions.
{{/note}}


{{/api_box_inline}}

{{#api_box_inline isolate}}

Each template runs as its own reactive computation.  When the template
accesses a reactive data source, such as by calling `Session.get` or
making a database query, this establishes a data dependency that will
cause the whole template to be re-rendered when the data changes.
This means that the amount of re-rendering for a particular change
is affected by how you've divided your HTML into templates.

Typically, the exact extent of re-rendering is not crucial, but if you
want more control, such as for performance reasons, you can use the
`{{dstache}}#isolate}}...{{dstache}}/isolate}}` helper.  Data
dependencies established inside an `#isolate` block are localized to
the block and will not in themselves cause the parent template to be
re-rendered.  This block helper essentially conveys the reactivity
benefits you would get by pulling the content out into a new
sub-template.

{{/api_box_inline}}

<h2 id="match"><span>Match</span></h2>

Meteor methods and publish functions take arbitrary [EJSON](#ejson) types as
arguments, but most arguments are expected to be of a particular type. Meteor's
`check` package is a lightweight library for checking that arguments and other
values are of the expected type. For example:

    Meteor.publish("chats-in-room", function (roomId) {
      // Make sure roomId is a string, not an arbitrary mongo selector object.
      check(roomId, String);
      return Chats.find({room: roomId});
    });

    Meteor.methods({addChat: function (roomId, message) {
      check(roomId, String);
      check(message, {
        text: String,
        timestamp: Date,
        // Optional, but if present must be an array of strings.
        tags: Match.Optional([String])
      });

      // ... do something with the message ...
    }});

{{> api_box check}}

If the match fails, `check` throws a `Match.Error` describing how it failed. If
this error gets sent over the wire to the client, it will appear only as
`Meteor.Error(400, "Match Failed")`; the failure details will be written to the
server logs but not revealed to the client.

{{> api_box match_test}}

{{#api_box_inline matchpatterns}}

The following patterns can be used as pattern arguments to `check` and `Match.test`:


<dl>
{{#dtdd "<code>Match.Any</code>"}}
Matches any value.
{{/dtdd}}

{{#dtdd "<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>undefined</code>, <code>null</code>"}}
Matches a primitive of the given type.
{{/dtdd}}

{{#dtdd "<code>Match.Integer</code>"}}
Matches a signed 32-bit integer. Doesn't match `Infinity`, `-Infinity`, or `NaN`.
{{/dtdd}}

{{#dtdd "<code>[<em>pattern</em>]</code>"}}
A one-element array matches an array of elements, each of which match
*pattern*. For example, `[Number]` matches a (possibly empty) array of numbers;
`[Match.Any]` matches any array.
{{/dtdd}}

{{#dtdd "<code>{<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...}</code>"}}
Matches an Object with the given keys, with values matching the given patterns.
If any *pattern* is a `Match.Optional`, that key does not need to exist
in the object. The value may not contain any keys not listed in the pattern.
The value must be a plain Object with no special prototype.
{{/dtdd}}

{{#dtdd "<code>Match.ObjectIncluding({<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...})</code>"}}
Matches an Object with the given keys; the value may also have other keys
with arbitrary values.
{{/dtdd}}

{{#dtdd "<code>Object</code>"}}
Matches any plain Object with any keys; equivalent to
`Match.ObjectIncluding({})`.
{{/dtdd}}

{{#dtdd "<code>Match.Optional(<em>pattern</em>)</code>"}} Matches either
`undefined` or something that matches pattern. If used in an object this matches
only if the key is not set as opposed to the value being set to `undefined`.

    // In an object
    var pat = { name: Match.Optional(String) };
    check({ name: "something" }, pat) // OK
    check({}, pat) // OK
    check({ name: undefined }, pat) // Throws an exception

    // Outside an object
    check(undefined, Match.Optional(String)); // OK

{{/dtdd}}

{{#dtdd "<code>Match.OneOf(<em>pattern1</em>, <em>pattern2</em>, ...)</code>"}}
Matches any value that matches at least one of the provided patterns.
{{/dtdd}}

{{#dtdd "Any constructor function (eg, <code>Date</code>)"}}
Matches any element that is an instance of that type.
{{/dtdd}}

{{#dtdd "<code>Match.Where(<em>condition</em>)</code>"}}
Calls the function *condition* with the value as the argument. If *condition*
returns true, this matches. If *condition* throws a `Match.Error` or returns
false, this fails. If *condition* throws any other error, that error is thrown
from the call to `check` or `Match.test`. Examples:

    check(buffer, Match.Where(EJSON.isBinary));

    NonEmptyString = Match.Where(function (x) {
      check(x, String);
      return x.length > 0;
    });
    check(arg, NonEmptyString);
{{/dtdd}}
</dl>

{{/api_box_inline}}

<h2 id="timers"><span>Timers</span></h2>

Meteor uses global environment variables
to keep track of things like the current request's user.  To make sure
these variables have the right values, you need to use
`Meteor.setTimeout` instead of `setTimeout` and `Meteor.setInterval`
instead of `setInterval`.

These functions work just like their native JavaScript equivalents.
If you call the native function, you'll get an error stating that Meteor
code must always run within a Fiber, and advising to use
`Meteor.bindEnvironment`.

{{> api_box setTimeout}}

Returns a handle that can be used by `Meteor.clearTimeout`.

{{> api_box setInterval}}

Returns a handle that can be used by `Meteor.clearInterval`.

{{> api_box clearTimeout}}
{{> api_box clearInterval}}

<h2 id="deps"><span>Deps</span></h2>

Meteor has a simple dependency tracking system which allows it to
automatically rerun templates and other computations whenever
[`Session`](#session) variables, database queries, and other data
sources change.

Unlike most other systems, you don't have to manually declare these
dependencies &mdash; it "just works". The mechanism is simple and
efficient. When you call a function that supports reactive updates
(such as a database query), it automatically saves the current
Computation object, if any (representing, for example, the current
template being rendered).  Later, when the data changes, the function
can "invalidate" the Computation, causing it to rerun (rerendering the
template).

Applications will find [`Deps.autorun`](#deps_autorun) useful, while more
advanced facilities such as `Deps.Dependency` and `onInvalidate`
callbacks are intended primarily for package authors implementing new
reactive data sources.

{{> api_box deps_autorun }}

`Deps.autorun` allows you to run a function that depends on reactive data
sources, in such a way that if there are changes to the data later,
the function will be rerun.

For example, you can monitor a cursor (which is a reactive data
source) and aggregate it into a session variable:

    Deps.autorun(function () {
      var oldest = _.max(Monkeys.find().fetch(), function (monkey) {
        return monkey.age;
      });
      if (oldest)
        Session.set("oldest", oldest.name);
    });

Or you can wait for a session variable to have a certain value, and do
something the first time it does, calling `stop` on the computation to
prevent further rerunning:

    Deps.autorun(function (c) {
      if (! Session.equals("shouldAlert", true))
        return;

      c.stop();
      alert("Oh no!");
    });

The function is invoked immediately, at which point it may alert and
stop right away if `shouldAlert` is already true.  If not, the
function is run again when `shouldAlert` becomes true.

A change to a data dependency does not cause an immediate rerun, but
rather "invalidates" the computation, causing it to rerun the next
time a flush occurs.  A flush will occur automatically as soon as
the system is idle if there are invalidated computations.  You can
also use [`Deps.flush`](#deps_flush) to cause an immediate flush of
all pending reruns.

If you nest calls to `Deps.autorun`, then when the outer call stops or
reruns, the inner call will stop automatically.  Subscriptions and
observers are also automatically stopped when used as part of a
computation that is rerun, allowing new ones to be established.  See
[`Meteor.subscribe`](#meteor_subscribe) for more information about
subscriptions and reactivity.

If the initial run of an autorun throws an exception, the computation
is automatically stopped and won't be rerun.

{{> api_box deps_flush }}

Normally, when you make changes (like writing to the database),
their impact (like updating the DOM) is delayed until the system is
idle. This keeps things predictable &mdash; you can know that the DOM
won't go changing out from under your code as it runs. It's also one
of the things that makes Meteor fast.

`Deps.flush` forces all of the pending reactive updates to complete.
For example, if an event handler changes a Session
variable that will cause part of the user interface to rerender, the
handler can call `flush` to perform the rerender immediately and then
access the resulting DOM.

An automatic flush occurs whenever the system is idle which performs
exactly the same work as `Deps.flush`.  The flushing process consists
of rerunning any invalidated computations.  If additional
invalidations happen while flushing, they are processed as part of the
same flush until there is no more work to be done.  Callbacks
registered with [`Meteor.afterFlush`](#deps_afterflush) are called
after processing outstanding invalidations.

Any auto-updating DOM elements that are found to not be in the
document during a flush may be cleaned up by Meteor (meaning that
Meteor will stop tracking and updating the elements, so that the
browser's garbage collector can delete them).  So, if you manually
call `flush`, you need to make sure that any auto-updating elements
that you have created by calling [`Meteor.render`](#meteor_render)
have already been inserted in the main DOM tree.

It is illegal to call `flush` from inside a `flush` or from a running
computation.

{{> api_box deps_nonreactive }}

Calls `func()` with `Deps.currentComputation` temporarily set to
`null`.  If `func` accesses reactive data sources, these data sources
will never cause a rerun of the enclosing computation.

{{> api_box deps_active }}

This value is useful for data source implementations to determine
whether they are being accessed reactively or not.

{{> api_box deps_currentcomputation }}

It's very rare to need to access `currentComputation` directly.  The
current computation is used implicitly by
[`Deps.active`](#deps_active) (which tests whether there is one),
[`dependency.depend()`](#dependency_depend) (which registers that it depends on a
dependency), and [`Deps.onInvalidate`](#deps_oninvalidate) (which
registers a callback with it).

{{> api_box deps_oninvalidate }}

See [*`computation`*`.onInvalidate`](#computation_oninvalidate) for more
details.

{{> api_box deps_afterflush }}

Functions scheduled by multiple calls to `afterFlush` are guaranteed
to run in the order that `afterFlush` was called.  Functions are
guaranteed to be called at a time when there are no invalidated
computations that need rerunning.  This means that if an `afterFlush`
function invalidates a computation, that computation will be rerun
before any other `afterFlush` functions are called.

<h2 id="deps_computation"><span>Deps.Computation</span></h2>

A Computation object represents code that is repeatedly rerun in
response to reactive data changes.  Computations don't have return
values; they just perform actions, such as rerendering a template on
the screen.  Computations are created using [`Deps.autorun`](#deps_autorun).
Use [`stop`](#computation_stop) to prevent further rerunning of a
computation.

Each time a computation runs, it may access various reactive data
sources that serve as inputs to the computation, which are called its
dependencies.  At some future time, one of these dependencies may
trigger the computation to be rerun by invalidating it.  When this
happens, the dependencies are cleared, and the computation is
scheduled to be rerun at flush time.

The *current computation*
([`Deps.currentComputation`](#deps_currentcomputation)) is the
computation that is currently being run or rerun (computed), and the
one that gains a dependency when a reactive data source is accessed.
Data sources are responsible for tracking these dependencies using
[`Deps.Dependency`](#deps_dependency) objects.

Invalidating a computation sets its `invalidated` property to true
and immediately calls all of the computation's `onInvalidate`
callbacks.  When a flush occurs, if the computation has been invalidated
and not stopped, then the computation is rerun by setting the
`invalidated` property to `false` and calling the original function
that was passed to `Deps.autorun`.  A flush will occur when the current
code finishes running, or sooner if `Deps.flush` is called.

Stopping a computation invalidates it (if it is valid) for the purpose
of calling callbacks, but ensures that it will never be rerun.

Example:

    // if we're in a computation, then perform some clean-up
    // when the current computation is invalidated (rerun or
    // stopped)
    if (Deps.active) {
      Deps.onInvalidate(function () {
        x.destroy();
        y.finalize();
      });
    }

{{> api_box computation_stop}}

Stopping a computation is irreversible and guarantees that it will
never be rerun.  You can stop a computation at any time, including
from the computation's own run function.  Stopping a computation that
is already stopped has no effect.

Stopping a computation causes its `onInvalidate` callbacks to run
immediately if it is not currently invalidated.

Nested computations are stopped automatically when their enclosing
computation is rerun.

{{> api_box computation_invalidate }}

Invalidating a computation marks it to be rerun at
[flush time](#deps_flush), at
which point the computation becomes valid again.  It is rare to
invalidate a computation manually, because reactive data sources
invalidate their calling computations when they change.  Reactive data
sources in turn perform this invalidation using one or more
[`Deps.Dependency`](#deps_dependency) objects.

Invalidating a computation immediately calls all `onInvalidate`
callbacks registered on it.  Invalidating a computation that is
currently invalidated or is stopped has no effect.  A computation can
invalidate itself, but if it continues to do so indefinitely, the
result will be an infinite loop.

{{> api_box computation_oninvalidate }}

`onInvalidate` registers a one-time callback that either fires
immediately or as soon as the computation is next invalidated or
stopped.  It is used by reactive data sources to clean up resources or
break dependencies when a computation is rerun or stopped.

To get a callback after a computation has been recomputed, you can
call [`Deps.afterFlush`](#deps_afterflush) from `onInvalidate`.

{{> api_box computation_stopped }}

{{> api_box computation_invalidated }}

This property is initially false.  It is set to true by `stop()` and
`invalidate()`.  It is reset to false when the computation is
recomputed at flush time.

{{> api_box computation_firstrun }}

This property is a convenience to support the common pattern where a
computation has logic specific to the first run.

<h2 id="deps_dependency"><span>Deps.Dependency</span></h2>

A Dependency represents an atomic unit of reactive data that a
computation might depend on.  Reactive data sources such as Session or
Minimongo internally create different Dependency objects for different
pieces of data, each of which may be depended on by multiple
computations.  When the data changes, the computations are
invalidated.

Dependencies don't store data, they just track the set of computations to
invalidate if something changes.  Typically, a data value will be
accompanied by a Dependency object that tracks the computations that depend
on it, as in this example:

    var weather = "sunny";
    var weatherDep = new Deps.Dependency;

    var getWeather = function () {
      weatherDep.depend()
      return weather;
    };

    var setWeather = function (w) {
      weather = w;
      // (could add logic here to only call changed()
      // if the new value is different from the old)
      weatherDep.changed();
    };

This example implements a weather data source with a simple getter and
setter.  The getter records that the current computation depends on
the `weatherDep` dependency using `depend()`, while the setter
signals the dependency to invalidate all dependent computations by
calling `changed()`.

The reason Dependencies do not store data themselves is that it can be
useful to associate multiple Dependencies with the same piece of data.
For example, one Dependency might represent the result of a database
query, while another might represent just the number of documents in
the result.  A Dependency could represent whether the weather is sunny
or not, or whether the temperature is above freezing.
[`Session.equals`](#session_equals) is implemented this way for
efficiency.  When you call `Session.equals("weather", "sunny")`, the
current computation is made to depend on an internal Dependency that
does not change if the weather goes from, say, "rainy" to "cloudy".

Conceptually, the only two things a Dependency can do are gain a
dependent and change.

A Dependency's dependent computations are always valid (they have
`invalidated === false`).  If a dependent is invalidated at any time,
either by the Dependency itself or some other way, it is immediately
removed.

{{> api_box dependency_changed }}

{{> api_box dependency_depend }}

`dep.depend()` is used in reactive data source implementations to record
the fact that `dep` is being accessed from the current computation.

{{> api_box dependency_hasdependents }}

For reactive data sources that create many internal Dependencies,
this function is useful to determine whether a particular Dependency is
still tracking any dependency relationships or if it can be cleaned up
to save memory.

<h2 id="ejson"><span>EJSON</span></h2>

EJSON is an extension of JSON to support more types. It supports all JSON-safe
types, as well as:

 - **Date** (JavaScript `Date`)
 - **Binary** (JavaScript `Uint8Array` or the
   result of [`EJSON.newBinary`](#ejson_new_binary))
 - **User-defined types** (see [`EJSON.addType`](#ejson_add_type).  For example,
 [`Meteor.Collection.ObjectID`](#collection_object_id) is implemented this way.)

All EJSON serializations are also valid JSON.  For example an object with a date
and a binary buffer would be serialized in EJSON as:

    {
      "d": {"$date": 1358205756553},
      "b": {"$binary": "c3VyZS4="}
    }

Meteor supports all built-in EJSON data types in publishers, method arguments
and results, Mongo databases, and [`Session`](#session) variables.

{{> api_box ejsonParse}}

{{> api_box ejsonStringify}}

{{> api_box ejsonFromJSONValue}}

{{> api_box ejsonToJSONValue}}

{{> api_box ejsonEquals}}

{{> api_box ejsonClone}}

{{> api_box ejsonNewBinary}}

Buffers of binary data are represented by `Uint8Array` instances on JavaScript
platforms that support them.  On implementations of JavaScript that do not
support `Uint8Array`, binary data buffers are represented by standard arrays
containing numbers ranging from 0 to 255, and the `$Uint8ArrayPolyfill` key
set to `true`.

{{> api_box ejsonIsBinary}}

{{> api_box ejsonAddType}}

When you add a type to EJSON, Meteor will be able to use that type in:

 - publishing objects of your type if you pass them to publish handlers.
 - allowing your type in the return values or arguments to
   [methods](#methods_header).
 - storing your type client-side in Minimongo.
 - allowing your type in [`Session`](#session) variables.

{{#note}}

  MongoDB cannot store most user-defined types natively on the server.  Your
  type will work in Minimongo, and you can send it to the client using a custom
  publisher, but MongoDB can only store the types defined in
  [BSON](http://bsonspec.org/).

{{/note}}

Instances of your type should implement the following interface:

{{> api_box ejsonTypeClone}}

{{> api_box ejsonTypeEquals}}

The `equals` method should define an [equivalence
relation](http://en.wikipedia.org/wiki/Equivalence_relation).  It should have
the following properties:

 - *Reflexivity* - for any instance `a`: `a.equals(a)` must be true.
 - *Symmetry* - for any two instances `a` and `b`: `a.equals(b)` if and only if `b.equals(a)`.
 - *Transitivity* - for any three instances `a`, `b`, and `c`: `a.equals(b)` and `b.equals(c)` implies `a.equals(c)`.

{{> api_box ejsonTypeName}}
{{> api_box ejsonTypeToJSONValue}}

For example, the `toJSONValue` method for
[`Meteor.Collection.ObjectID`](#collection_object_id) could be:

    function () {
      return this.toHexString();
    };

<h2 id="http"><span>HTTP</span></h2>

`HTTP` provides an HTTP request API on the client and server.  To use
these functions, add the HTTP package to your project with `$ meteor add http`.

{{> api_box httpcall}}

This function initiates an HTTP request to a remote server.

On the server, this function can be run either synchronously or
asynchronously.  If the callback is omitted, it runs synchronously
and the results are returned once the request completes successfully.
If the request was not successful, an error is thrown.
This is
useful when making server-to-server HTTP API calls from within Meteor
methods, as the method can succeed or fail based on the results of the
synchronous HTTP call.  In this case, consider using
[`this.unblock()`](#method_unblock) to allow other methods on the same
connection to run in
the mean time.  On the client, this function must be used
asynchronously by passing a callback.

Both HTTP and HTTPS protocols are supported.  The `url` argument must be
an absolute URL including protocol and host name on the server, but may be
relative to the current host on the client.  The `query` option
replaces the query string of `url`.  Parameters specified in `params`
that are put in the URL are appended to any query string.
For example, with a `url` of `"/path?query"` and
`params` of `{foo:"bar"}`, the final URL will be `"/path?query&foo=bar"`.

The `params` are put in the URL or the request body, depending on the
type of request.  In the case of request with no bodies, like GET and
HEAD, the parameters will always go in the URL.  For a POST or other
type of request, the parameters will be encoded into the body with a
standard `x-www-form-urlencoded` content type, unless the `content`
or `data` option is used to specify a body, in which case the
parameters will be appended to the URL instead.

When run in asynchronous mode, the callback receives two arguments,
`error` and `result`.  The
`error` argument will contain an Error if the request fails in any
way, including a network error, time-out, or an HTTP status code in
the 400 or 500 range.  In case of a 4xx/5xx HTTP status code, the
`response` property on `error` matches the contents of the result
object.  When run in synchronous mode, either `result` is returned
from the function, or `error` is thrown.

Contents of the result object:

<dl class="objdesc">

<dt><span class="name">statusCode</span>
  <span class="type">Number</span></dt>
<dd>Numeric HTTP result status code, or <code>null</code> on error.</dd>

<dt><span class="name">content</span>
  <span class="type">String</span></dt>
<dd>The body of the HTTP response as a string.</dd>

<dt><span class="name">data</span>
  <span class="type">Object or <code>null</code></span></dt>
<dd>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</dd>

<dt><span class="name">headers</span>
  <span class="type">Object</span></dt>
<dd>A dictionary of HTTP headers from the response.</dd>

</dl>

Example server method:

    Meteor.methods({checkTwitter: function (userId) {
      check(userId, String);
      this.unblock();
      try {
        var result = HTTP.call("GET", "http://api.twitter.com/xyz",
                               {params: {user: userId}});
        return true;
      } catch (e) {
        // Got a network error, time-out or HTTP error in the 400 or 500 range.
        return false;
      }
    }});

Example asynchronous HTTP call:

    HTTP.call("POST", "http://api.twitter.com/xyz",
              {data: {some: "json", stuff: 1}},
              function (error, result) {
                if (!error) {
                  Session.set("twizzled", true);
                }
              });


{{> api_box http_get}}
{{> api_box http_post}}
{{> api_box http_put}}
{{> api_box http_del}}


<h2 id="email"><span>Email</span></h2>

The `email` package allows sending email from a Meteor app. To use it, add the
package to your project with `$ meteor add email`.

The server reads from the `MAIL_URL` environment variable to determine how to
send mail. Currently, Meteor supports sending mail over SMTP; the `MAIL_URL`
environment variable should be of the form
`smtp://USERNAME:PASSWORD@HOST:PORT/`. For apps deployed with `meteor deploy`,
`MAIL_URL` defaults to an account (provided by
[Mailgun](http://www.mailgun.com/)) which allows apps to send up to 200 emails
per day; you may override this default by assigning to `process.env.MAIL_URL`
before your first call to `Email.send`.

If `MAIL_URL` is not set (eg, when running your application locally),
`Email.send` outputs the message to standard output instead.

{{> api_box email_send }}

You must provide the `from` option and at least one of `to`, `cc`, and `bcc`;
all other options are optional.

`Email.send` only works on the server. Here is an example of how a
client could use a server method call to send an email. (In an actual
application, you'd need to be careful to limit the emails that a
client could send, to prevent your server from being used as a relay
by spammers.)

    // In your server code: define a method that the client can call
    Meteor.methods({
      sendEmail: function (to, from, subject, text) {
        check([to, from, subject, text], [String]);

        // Let other method calls from the same client start running,
        // without waiting for the email sending to complete.
        this.unblock();

        Email.send({
          to: to,
          from: from,
          subject: subject,
          text: text
        });
      }
    });

    // In your client code: asynchronously send an email
    Meteor.call('sendEmail',
                'alice@example.com',
                'bob@example.com',
                'Hello from Meteor!',
                'This is a test of Email.send.');

{{/better_markdown}}

<h2 id="assets"><span>Assets</span></h2>

{{#better_markdown}}
`Assets` allows server code in a Meteor application to access static server
assets, which are located in the `private` subdirectory of an application's
tree.

{{> api_box assets_getText }}
{{> api_box assets_getBinary }}

Static server assets are included by placing them in the application's `private`
subdirectory. For example, if an application's `private` subdirectory includes a
directory called `nested` with a file called `data.txt` inside it, then server
code can read `data.txt` by running:

    var data = Assets.getText('nested/data.txt');
{{/better_markdown}}

</template>






<template name="api_box">
<div class="api {{bare}}">
<h3 id="{{id}}">
  <a class="name selflink" href="#{{id}}">{{{name}}}</a>
{{#if locus}}
  <span class="locus">{{locus}}</span>
{{/if}}
</h3>

<div class="desc">
{{#each descr}}{{#better_markdown}}{{{this}}}{{/better_markdown}}{{/each}}
</div>

{{#if args}}
<h4>Arguments</h4>
{{> api_box_args args}}
{{/if}}

{{#if options}}
<h4>Options</h4>
{{> api_box_args options}}
{{/if}}

{{#if body}}
{{#better_markdown}}{{{body}}}{{/better_markdown}}
{{/if}}

</div>

</template>



<template name="api_box_args">
<dl class="args">
{{#each this}}
<dt><span class="name">{{{name}}}</span>
  <span class="type">
    {{#if type_link}}
      <a href="#{{type_link}}">{{{type}}}</a>
    {{else}}
      {{{type}}}
    {{/if}}
  </span></dt>
<dd>{{#better_markdown}}{{{descr}}}{{/better_markdown}}</dd>
{{/each}}
</dl>
</template>


<template name="api_section_helper">
<h2 id="{{id}}"><a href="#{{id}}" class="selflink"><span>{{name}}</span></a></h2>
</template>
